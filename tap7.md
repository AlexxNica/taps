* TAP: 7
* Title: Conformance testing
* Version: 2
* Last-Modified: 25-May-2017
* Author: Vladimir Diaz, Sebastien Awwad
* Status: Draft
* Content-Type: text/markdown
* Created: 20-Jan-2017

# Abstract

[Conformance testing](https://en.wikipedia.org/wiki/Conformance_testing) can
determine whether an implementation meets the requirements set by a given
specification.  At this point, no tool exists to help developers and users affirm
that an implementation behaves according to the TUF specification. Although
the reference implementation contains [unit
tests](https://github.com/theupdateframework/tuf/tree/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/tests)
that verify correct behavior, such as updating metadata in the expected order
and blocking known updater attacks, these unit tests only work within the
parameters of the reference implementation, which is problematic due to the diversity
of TUF implementations.

To achieve the goal of testing diverse TUF implementations, this specification describes the
design of a common testing tool for TUF conformance.  The goals are to interoperate with
implementations in diverse languages and environments, while having a low burden on
TUF implementers to the tool in their environment.

# Motivation

Up to this point, adopters of TUF who had written an implementation could only test
for conformance by (1) verifying that metadata generated in some language X
matches that of the reference implementation, and/or (2) reproducing the unit
tests of the reference implementation in language X.  In the first case, only
the metadata generated by X can be said to conform to the specifications. The client
would still need to test for the expected behavior when the generated
metadata is updated.  In the second case, the implementation is said to
conform depending on how thoroughly the unit tests are reproduced in X.
There are bound to be inconsistencies between the two sets of unit tests. Any
improvements in TUF testing or changes to the program would require
implementers to add test code in parallel.  A
single tool for conformance testing can avoid issues with interoperability and
duplicate work, can ensure update behavior as intended by the designers of TUF,
and, most importantly, ensure that an updater is secure against
the types of attacks and weaknesses listed in
[Section 1.5.2](https://github.com/theupdateframework/tuf/blob/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/docs/tuf-spec.txt#L124-L181)
of the TUF Specification. In addition, the official tool should be publicly
available and useable by anyone who wishes to test an implementation.

Passing a conformance test with the official tool would be
an important step in checking if an implementation is TUF-conformant.

# Rationale

Developers need a convenient way of verifying whether an implementation
conforms to the TUF specification. Such a verification could be quite desirable,
as it would affirm that the tested implementation meets a recognized standard of
secure operation. One possible verification method could be to define, and ideally
automate, the expected outcome of an update request when given different sets of
input metadata. If an implementation is given the Root file and instructed to
download a particular package, its ability to correctly download both the required
top-level metadata and the requested package could indicate conformance.  Moreover,
if it is able to do so while still preventing the attacks listed in the specification,
that claim becomes stronger.  Consequently, any
implementation of TUF would need some way of accepting given metadata
and indicating when it has detected a particular attack.

This TAP prescribes that an implementation of a client updater ("Updater")
employ a wrapper module ("Wrapper") that implements a common set of functions
defined in this document. These can be called by a general TUF Conformance
Tester ("Tester"), which will pass in sets of metadata and target files. The
Tester will determine based on output produced by the wrapped Updater --
including error codes that signal that particular attacks have been detected --
whether or not the Updater is conformant with the TUF specification. In
general, these constitute a battery of attacks against which the Updater should
be resilient.

It should be noted, however, that the implementation does not necessarily have
to be the updater used in production. It only needs to function as defined in
this TAP for conformance testing, though it is expected that the behavior be
the same at a high level -- for example, the validity of metadata should be
determined the same way. ((TODO: This paragraph still seems wordy. Unnecessary?))

# Specification

In order to help determine the TUF-conformance of a particular updater
implementation, the following components are required by this TAP:
- Updater
- Conformance Tester
- Wrapper

The **Updater** is the program to be tested, an implementation of a TUF-conformant
updater client, as described in
[the client section of the TUF specification](https://github.com/theupdateframework/tuf/blob/develop/docs/tuf-spec.txt#L931-L933).

The **Conformance Tester**, provided by TheUpdateFramework, will run a battery
of tests intended to determine the TUF-conformance of the Updater. The Tester
can be thought of as a source of metadata and targets that will ultimately be
received by the Updater, which must try to validate them correctly. The Updater
will be expected to reject untrustworthy metadata and targets and accept
trustworthy metadata and targets.

The **Wrapper** mediates communication between the Tester and Updater, adapting
metadata and communicating it in the way the Updater expects. An
individual Updater will need a custom Wrapper written for the Tester to use to
communicate with it. This will need to involve at least a few lines of Python.
In order for the Tester to interact with the Updater implementation, a Wrapper
around that implementation will need to support as an interface to the Tester
three functions.


## Wrapper Specification

The Wrapper must implement the three functions specified
[below](#wrapper-functions).
Note also, however, that because implementations may vary substantially, the
Wrapper may need to perform things like:
 - Calling an external binary with, e.g., the subprocess module, in order to
 run an updater implementation that is not in Python.
 - Moving metadata or target files into the directory structure the updater
 implementation expects
 - If, e.g., the Updater doesn't have a notion of a filesystem, the wrapper may
 need to read the files the tester provides and distribute data to the Updater
 in the manner the Updater expects.
 - Translate metadata from the format the tester provides into the custom
 format the Updater expects, potentially re-signing metadata if the Updater
 will expect signatures over a different format
 - If the Updater's communication model involves different synchronization
 (e.g. server push vs client pull), the update_client() Wrapper function will
 need to bridge this; for example, it may need to wait and collect results from
 some separate process.



### Wrapper Functions
The following functions must be written for the Wrapper module, and will be
called by the Tester.

[A skeletal module defining the functions below](tap7_resources/tap7_wrapper_skeleton.py)
is available.

- 1: **`initialize_updater(metadata_directory, keys, instructions)`**:
    - Purpose:
        Sets the client's initial state up for a future test, providing it with
        metadata to be treated as already-validated. A client updater delivered
        to end users will always need some kind of root of trust (in the TUF
        spec, an initial Root role metadata file, e.g. root.json) to use when
        validating future metadata.

    - Arguments:
        - `metadata_directory`:
          Metadata in the TUF specification's metadata format will be provided in
          the directory at path `metadata_directory`. This should be provided to
          the Updater in whatever form it requires. The common case here will be
          the path of a directory containing a trustworthy root.json file.
          The structure of this directory is the same as that used by the
          TUF Reference Implementation, made compatible with [TAP 4](tap4.md).
          Structure of metadata_directory:
            ```

            ```
        - `keys`
          If the Updater can process signatures in TUF's default metadata, then
          you SHOULD IGNORE this argument.
          This is provided only in case the metadata format the Updater expects
          signatures to be made over is not the same as the metadata format that
          TUF signs over (canonicalized JSON).
          If the Updater uses a different metadata format, then you may need to
          re-sign the metadata the Tester provides in the metadata_directory.
          This dict contains the signing keys that can be used to re-sign the
          metadata.
        - `instructions`
          If the Updater can process signatures in TUF's default metadata, then
          you SHOULD IGNORE this argument.
          This, too, is provided only in case the metadata format the Updater
          expects signatures to be made over is not the same as the metadata
          format that TUF signs over (canonicalized JSON).
          If you'll be re-signing the metadata provided here, then this
          dictionary of instructions will tell you what, if any, modifications
          to make. For example, {'invalidate_signature': True} instructs that
          the signature be made and then some byte(s) in it be modified so that
          it is no longer a valid signature over the metadata.

    - Returns: None

- 2: **`update_repo(metadata_directory, targets_directory, keys, instructions)`**:
    - Purpose:
        Updates the repository files, metadata and targets. This will be the
        data that should be made available to the Updater when the Updater
        tries to update.

    - Arguments:
        - `metadata_directory`:
          See `initialize_updater` above.
        - `targets_directory`:
          The path of a directory containing target files that should be made
          available to the Updater.
        - `keys`
          See `initialize_updater` above.
        - `instructions`
          See `initialize_updater` above.

    - Returns: None


- 3: **`update_client(target_filepath)`**:
    - Purpose:
        Refreshes metadata and causes the client to attempt to (obtain and)
        validate a particular target,
        along with all metadata required to do so in a secure manner conforming to
        the TUF specification.

        This function will have to translate Updater behavior/output into the
        return values (below) that the Tester expects, based on
        whether or not the Updater detects a particular attack. `update_client`
        must return the appropriate code to the Tester, which will evaluate them
        against what it expects.

    - Arguments:
        - `target_filepath`:
          The path of a target file that the Updater should try to update.
          This must be inside the `targets_directory` directory provided to
          `update_repo`, and it should be written relative to
          `targets_directory`. As noted previously, it is not necessary for the
          Updater to have a notion of files; `update_client` may abstract this
          away.

    - Returns:
        An integer describing the result of the attempted update. This value is
        what the Tester is ultimately testing.

        ```
        return value     outcome
        -----------      ------
        0                SUCCESS: target identified by target_filepath has been
                         obtained from one of the mirrors and validated per
                         trustworthy metadata
        1                FAILURE/rejection: unable to obtain a target identified
                         by target_filepath from any of the known mirrors that
                         is valid according to trustworthy metadata
        2                an unknown error has occurred (never expected, but
                         helpful to provide for test output)

        # TODO: Consider additional return fields:
          hash: (Verdict: No, for now)
            the hash of the target file installed if there was a target file
            validated and "installed" (to be tested against the expected
            fileinfo). This may allow us to make sure that the success was real
            / the right target was actually chosen.
            This is probably not necessary, but it's food for thought as we
            write tests.

          metadata versions: (Verdict: No)
            a dictionary mapping metadata filename to the version validated in
            this update. The purpose of this is to allow for an easier time
            writing the Tester, since it spares us the complication of making
            the test go so far as to validate a particular target in a large
            number of sub-tests when all we want to do is determine that e.g.
            replayed metadata is rejected. Tests are just more complicated to
            construct sometimes otherwise. Not a good enough reason, IMO;
            simplicity for the external implementer is paramount.

        ```


See [Example Wrapper](#example-wrapper) below for an example of the Wrapper
module - in this case, a wrapper enabling the Conformance Tester to test the
TUF Reference Implementation.


## Test Specification

The Tester will verify that the Updater can
defend against the attacks and weaknesses discussed in the TUF specification.
Broadly, these include:

```
(1) arbitrary installation
(2) endless data
(3) extraneous dependencies
(4) fast-forward
(5) indefinite freeze
(6) malicious mirrors
(7) mix-and-match
(8) rollback
(9) vulnerability to key compromises
```

Note that the Conformance Tester generates the metadata
and targets that the implementation uses, and can test for various conditions.
For instance, the Tester can generate metadata signed by an invalid key,
so it can test whether the implementation will reject
an untrusted signature.


### Test Battery

The full listing of conformance tests will be specified in documentation
alongside the TUF Specification. The following listing provides examples.

A set of static metadata may also be provided, but the best results will come
from metadata and targets dynamically generated by the Tester.

In each of the tests below, the new metadata to be validated, provided in the
`update_repo` call, will describe a new target. This new target will not have
been described by the initial metadata that the client is treating as already-
validated (provided in `initialize_updater` call). When the `update_client`
call specifies this new target, that target will only validate if the new
metadata has been validated and the target obtained matches that now-validated
metadata.

At least two cases will be run in each of the scenarios below, in a randomized
order:
 - Error case: a case as described in the Description, where the update attempt
 is expected to result in no update. The Wrapper is expected to return the
 value Failure (1) to the Tester. If the Updater supports multiple mirrors
 (See [Configuration File](#configuration-file)), then this test will be
 performed with two distinct "bad" mirrors each modified as described in the
 Description.
 - Control case: a case absent the malicious/erroneous modification in the
 Description. The Wrapper is expected to return the value Success (0) to the
 Tester.
 If the Updater supports multiple mirrors, then this test will
 instead be performed with one "bad" mirror (set up as described in the
 Description) and one "good" mirror (absent the malicious/erroneous
 modification in the Description).

#### Case Multipliers
When a Case Set below lists one of these multipliers, the number of tests of
that case set will need to be multiplied in the listed way.
- **Per Role**
    - Run the case at least four different ways, where the offending metadata
      is a different role: Timestamp, Snapshot, Target, and Root.
      If delegated target roles are supported (See
      [Configuration File](#configuration-file)), then a delegated target role
      file should also be tested.

#### Case Sets

These can be expanded to indicate more about the definitions of the test cases,
e.g. what calls are made to the Wrapper and a description of the arguments
provided (e.g. the files in the directories indicated by the arguments)

##### Target tampering w/ no compromised keys
  - Return Value Expected: Failure (1)
  - Description: Metadata is unaltered, but the target file is altered and does
    not match signed hash in metadata.
  - Multipliers: Per Role

##### Metadata tampering w/ no compromised keys
  - Return Value Expected: Failure (1)
  - Description: Signed metadata is altered and the signature
    on that signed metadata is unaltered and no longer valid.
  - Multipliers: Per Role

##### Freezes / Expired metadata provided for validation
  - Return Value Expected: Failure (1)
  - Description: The metadata role in question is altered to make its
    expiration earlier than the current date/time (to test expiry)
  - Multipliers: Per Role

##### Replays / Old but unexpired metadata provided for validation
  - Return Value Expected: Failure (1)
  - Description: A metadata role provided for validation by the mirror has a
    lower version number than that of the corresponding role that has already
    been validated.
  - Multipliers: Per Role

...
ETC
...




## Example Wrapper

Here's a sample Wrapper module that allows the Conformance Tester to test the
TUF Reference Implementation.

(((TODO: NOTE that I need to continue to go through the below. It's
not finished. I also have to indent the below properly. (Avoiding now to avoid
misleading commit diffs))))

```Python

def initialize_updater(metadata_directory):
# TODO: Copy the contents of the given directory to a temp directory and host
# that via http simpleserver on port 8001 on localhost.
# TODO: Initialize a tuf.client.updater.Updater object and stick the given
# metadata files into its current metadata directory. (Such code exists in the
# Uptane demo already. Grab from there.)

# The HTTP repository that serves metadata and update files to client.  Not
# all implementations of the framework use this transport mechanism to serve
# files.
REPOSITORY_MIRROR = http://localhost:8001

# Set the local repository directory containing all of the metadata files.
tuf.settings.repositories_directory = metadata_directory

# Set the repository mirrors.  This dictionary is needed by the Updater
# client.
repository_mirrors = {'mirror': {'url_prefix': REPOSITORY_MIRROR,
                                'metadata_path': 'metadata',
                                'targets_path': 'targets'}}

# Create the repository object using the repository name 'repository'
# and the repository mirrors defined above.
updater = tuf.client.updater.Updater('repository', repository_mirrors)

# The local destination directory to save the target files, which
# we get from the command line argument supplied to this wrapper script.
destination_directory = targets_directory

# ...


def update_repo(metadata_directory, targets_directory):
# TODO: Copy the given files into place in the hosted repository directory.


def update_client(target_filepath):

# Refresh the repository's top-level roles, store the target information for
# all the targets tracked, and determine which of these targets have been
# updated.
updater.refresh(unsafely_update_root_if_necessary=False)

# Retrieve the target info of the 'target_filepath' argument, which contains
# its length, hash, etc.
file_targetinfo = updater.get_one_valid_targetinfo(target_filepath)
updated_targets = updater.updated_targets([file_targetinfo], destination_directory)

# Download each of these updated targets and save them to the local
# 'targets_directory' supplied to the script.  The conformance tool
# can verify the files saved unmodified to 'targets_directory'.
try:
  updater.download_target(file_targetinfo, destination_directory)

except tuf.NoWorkingMirrorError:
  return FAILURE

# TODO: Check if the target file has been obtained and retained post-validation
if #obtained and retained#:
  return SUCCESS
else:
  return FAILURE
```

As shown in the code snippet above, the Wrapper functions loads metadata from
the directories specified. The Updater.download_target() call in the TUF
reference implementation employs the suite of TUF verifications to obtain the
target file indicated and retain it only if it validates, updating metadata as
necessary.


### Configuration File
To launch the test, the conformance tester accepts a
command-line option that points to
the location of a configuration file.

The configuration file includes the name of the module that provides the
Wrapper functions specified above, along with any necessary restrictions on
TUF functionality, such as the list of
cryptographic key types supported by the updater, the number of root keys,
thresholds, etc.  The configuration file is needed because restrictions
are not shared equally across all implementations.
For example, the Go implementation might only support ECDSA keys, whereas
another might support Ed25519 and RSA keys.

An example of a `.tuf-tester.yml` configuration file for a Python updater:

```
# The name of the Wrapper module, which will be imported and used by the
# Tester.
module: ref_impl_wrapper

# conformant_updater.py supports the following keytypes.
keytype: ed25519, ecdsa

# conformant_updater.py expects the Root file to be signed by a max of 3 different keys.
number-of-root-keys: 3

# For this Updater implementation, at a minimum, the Root file MUST be signed
# by at least 2 out of 3 Root keys.
root-threshold: 2

# Let's say that this Updater implementation doesn't support delegated Targets
# roles. (Default is true.)
delegated-roles-support: false

# Let's say that this Updater implementation doesn't support mirrors - it just
# uses one location for the repository. (Default is true.)
mirror-support: false
...
```

### Executing Conformance Testing
The command to execute the conformance testing tool is:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
```

In response, you'll likely see something along these lines:
```
normal update: check.
blocked freeze attack: check.
blocked rollback attack: check.
key revocation: check.
blocked endless data attack: check.
...

Congratulations! The implementation under test appears to conform with the TUF
specification.  More detailed information on the test results was saved to
test-results.txt
```

The conformance tester returns `0` if all tests return results as expected,
indicating that the implementation conforms to the specification.

If `conformance_tester.py` returns a non-zero return code,
it signals a failure. Optionally, a list of the conformance tests that the
updater failed is printed or logged.


### Dealing with Implementation Restrictions

#### Key Restrictions

Suppose, for example, that the Updater implementation has the following restrictions:
```
- only Ed25519 keys are used and listed in metadata
- only exactly 2 keys are supported for Root metadata, and only a threshold
    of 1  (((Is this necessary?)))
```
These restrictions can be handled by configuring the conformance tool via
its `.tuf-tester.yml` configuration file.  The configuration file can be edited
by the developer to list:

```
keytype: ed25519
number-of-root-keys: 2
root-threshold: 1
```

#### Metadata Conversion

(Note again that this is not necessary if the Updater uses the metadata format
specified in the TUF Specification.)

Suppose that metadata that the Updater receives must be encoded in DER (rather
than JSON). In this case, the Wrapper will need to convert the metadata
received from the Tester in `initialize_updater` and `update_repo` (specified
in [Wrapper Functions](#wrapper-functions) above).

For this reason, `initialize_updater` and `update_repo` also provide arguments
`keys` and `instructions`. The keys in `keys` will allow the Wrapper to
re-sign the metadata provided in a manner that the Updater will expect. If
there were manipulations made to the resulting metadata for test purposes
(such as invalidating the signature by changing a byte in it), the
`instructions` argument will describe these, so that they can be repeated in
the converted and re-signed metadata.

For an example of how such code might look, consider the JSON-to-DER converter
`convert_signed_metadata_to_der` employed by Uptane's TUF fork
[here](https://github.com/awwad/tuf/blob/36dbb7b8a800dab407fe9ab961155ef0a6d9f7c9/tuf/asn1_codec.py#L156-L352).

##### Re-Signing Converted Metadata
Two situations arise depending on the behavior of your Updater:
1. When the Updater receives the converted metadata, it converts it back to
canonical JSON and checks the signatures in this (original) format.
2. When the Updater receives the converted metadata, it will not convert it
back into canonical JSON, and will expect the signatures to be over the same
new format (foreign to TUF).

In the second case, the converted metadata must also be re-signed, so that the
Updater will be able to correctly validate the metadata.


(((TODO: I should probably add the *high-level* code here to do the ASN.1/DER
conversion, which is pretty short (asn1_coder.convert*(), inside function
definition blocks for the optional functions, to make this clearer to the
reader.))))


#### No File System
There might be TUF implementations
where metadata or update files are not saved to a file system on the
device.  In this case, the developer or user running the conformance tests
would need to arrange that the files which are requested and stored by the device
be saved unmodified to directories that *can* be accessed by the conformance
tests.  These directories would be specified in the command-line options of the
conformant updater or the conformance tool's configuration file (i.e., the
--client-metadata and --client-targets command-line options used in the
preceding examples).

What the conformance tool must ultimately verify are the metadata and update
file(s) that the updater eventually trusts, and not that these files are
"installed" in some particular manner. Additionally, the conformance tests must
confirm the updater's ability to detect the attacks covered in the
specification (with the exclusion of the slow retrieval attack).

Since testing of the slow retrieval attack depends on the transport mechanism
used by the implementation, it is up to the developer to test whether the
implementation is vulnerable to this attack.  This might entail
modifying an HTTP server to limit the rate at which requests are satisifed, or
inserting a MITM that intercepts XMLRPC traffic between the updater and server,
and then manipulating the rate of transfer.  Regardless of the transport
mechanism used, developers should take care to prevent their updaters from
being vulnerable to such attacks, which can happen before any data is
transferred, or after the transfer of data has begun.


## Summary of Steps for Conformance Testing
In summary, the steps that should be followed to test an Updater for
conformance to the TUF Specification are as follows:

```
(1) Write Wrapper module per specifications above.
(2) Configure conformance tool to abide by the adopter's repository restrictions.
(3) Run conformance tool and confirm that all tests are passed.
```

# Security Analysis

This TAP does not detract from existing security guarantees because it does not
propose architectual changes to the specification.

# Backwards Compatibility

This TAP does not introduce any backwards incompatibilities.

# Augmented Reference Implementation


A git branch containing the official tool for conformance testing, and a client
set up for conformance testing can be found at:
https://github.com/theupdateframework/tuf/tree/tap7/tuf/scripts/conformance_tester

**Note that the preceding must be updated to match recent modifications to
TAP 7.**


# Copyright

This document has been placed in the public domain.
