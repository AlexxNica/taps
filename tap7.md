* TAP: 7
* Title: Conformance testing
* Version: 1
* Last-Modified: 01-May-2017
* Author: Vladimir Diaz, Sebastien Awwad
* Status: Draft
* Content-Type: text/markdown
* Created: 20-Jan-2017

# Abstract

[Conformance testing](https://en.wikipedia.org/wiki/Conformance_testing) can
determine whether an implementation meets the requirements set by a
specification.  A tool that helps developers and users test that an
implementation behaves according to the TUF specification does not presently
exist.  Although the reference implementation contains [unit
tests](https://github.com/theupdateframework/tuf/tree/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/tests)
that verify correct behavior, such as updating metadata in the expected order
and blocking known updater attacks, these unit tests only work with the
reference implementation.  Conformance testing should instead work across
different languages and platforms.  To achieve the preceding aim, the
specification can endorse an official tool, compatible with any implementation,
and cover how an implementation can be set up for conformance testing.

# Motivation

Adopters of the framework who have written implementations have tried testing
for conformance by (1) verifying that metadata generated in some language X
matches that of the reference implementation, and/or (2) reproducing the unit
tests of the reference implementation in language X.  In the first case, only
the metadata generated by X can be said to be conformant.  However, the client
would still need to be tested for the expected behavior when the generated
metadata is updated.  In the second case, the implementation is said to be
conformant depending on how thoroughly the unit tests are reproduced in X.
There are bound to be inconsistencies between both sets of unit tests, and
improvements in TUF testing or changes to TUF would result in a need for
implementers to add test code in parallel, so a single tool is preferable.  A
single tool for conformance testing can avoid issues with interoperability,
duplicate work, ensuring update behavior as intended by the designers of the
framework, and most importantly it can ensure that an updater is secure against
the attacks and weaknesses listed in [section
1.5.2](https://github.com/theupdateframework/tuf/blob/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/docs/tuf-spec.txt#L124-L181)
(Goals for specific attacks to protect against) of the specification.  The
official tool should be publicly available and runnable by anyone who wishes to
test an implementation.

An implementation can be said to be TUF-compliant if it passes conformance
testing with the official tool.

# Rationale

Developers need a convenient way of verifying whether an implementation
conforms to the specification.  One solution is to define, and ideally
automate, the expected outcome of an update request given different sets of
input metadata.  If an implementation is given the Root file and instructed to
download a particular package, does it correctly download the required
top-level metadata and the requested package?  Does it do so while still
preventing the attacks listed in the specification?  Consequently, an
implementation of the framework would need some way of accepting given metadata
and indicating when it has detected a particular attack.

This TAP prescribes that an implementation, or a wrapper script for it, accept
a set of command-line arguments, which are defined here, and exit with return
codes under certain conditions (e.g., to signal that a Freeze attack was
detected).  A fixed set of arguments is needed so that conformance testing is
consistent across different languages.  In turn, the conformance tester will
execute the implementation with different sets of metadata and verify its exit
codes for numerous outcomes.  The conformance tester also requires a minimum
number of arguments so that it can thoroughly cover all potential outcomes that
it wishes to test.  It should be noted, however, that the implementation does
not necessarily have to be the updater used in production, only that it should
function as defined in this TAP for conformance testing.

An implementation under test will need to accept command-line arguments that
(1) indicate the target file to download when the program initiates an update,
(2) a directory containing the metadata and targets provided to the updater,
and (3) where requested metadata and target files are saved after a request
is made by the updater.  Specifically, the implementation needs to accept
the command-line arguments as follows:

```Bash
$ command foo.tgz tmp/remote-files tmp/metadata tmp/targets
```

A Python example:

```Bash
$ python example_updater.py
  --file foo.tgz
  --remote-files tmp/remote-files
  --metadata tmp/metadata
  --targets tmp/targets
```

In turn, the conformance tester executes this command when it runs its suite of
conformance tests, which will consist of testing for things like validating the
metadata downloaded by the updater and verifying that the following attacks are
blocked:

```
(1) Arbitrary installation
(2) endless data
(3) extraneous dependencies
(4) fast-forward
(5) indefinite freeze
(6) malicious mirrors
(7) mix-and-match
(8) rollback
(9) key compromise.
```

While testing, the conformance tester verifies that the expected metadata and
update files are downloaded, and examines the return codes of the program when
attacks on the updater are present, which are defined later in the
*Specification* section of this TAP.  Note that the conformance tester provides
the remote files (i.e., repository files) specified on the command-line, and so
it  can test for various conditions and input metadata.

As for running the conformance tests, the conformance tester accepts a
command-line option (and others, which will be covered later) that points to
the location of a configuration file:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
```

The configuration file includes the update command that the conformance tool
should execute to run the updater, and other restrictions such as the
cryptographic key types supported by the updater, the number of root keys,
thresholds, etc.  Why is a configuration file needed?  There are restrictions
set by different implementations that, although they abide by the
specification, are not shared across all implementations of the specification.
For example, the Go implementation might only support ECDSA keys, whereas
another might support Ed25519 and RSA keys.

Before running the conformance tests, the conformance tool generates a
`root.json` according to the restrictions set in `.tuf-tester.yml`, saves it to
*tmp/metadata* (or the path indicated by the metadata command-line option),
populates the directory containing the remote repository files, and executes
the update command.  The updater should load *tmp/metadata/root.json* (or the
appropriate path), refreshes metadata accordingly, and lastly fetches the
requested update file .

The update procedure of the program, which is to refresh metadadata and
download a single update file, is sufficient to cover all the requirements set
by the specification.  As brief examples: the conformance tool can start the
update program and feed it the correct metadata and update file when the
requests are made.  The tool will inspect the local metadata directory to
ensure that the correct metadata is downloaded, and that the update program
succeeds with a return code of `0`.  The tool can test the program for
detection of a rollback attack by providing a previously trusted version of
metadata (and thus update files), and confirming that the program exits with a
return code of `4` (a return code of `4` is defined in this TAP to mean that a
rollback error has occurred).

# Specification

The conformance tester stores `root.json` in the metadata directory indicated
on the command line (e.g., *tmp/metadata* above).  The root file is generated
according to the restrictions set in the configuration file.

The command to execute the conformance testing tool is:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
```

The conformance tester returns `0` if the implementation complies with the
specification.

conformance_tester.py returns a non-zero return code to signal a failure.
Optionally, a list of the conformance tests that the updater failed is printed
or logged.

An example of a `.tuf-tester.yml` configuration file for a Python updater:

```
# The command that the conformance tester executes to verify compliant_updater.py's
# conformity with the specification.
command: "python compliant_updater.py
  --file foo.tgz
  --remote-files tmp/remote-files
  --metadata tmp/metadata
  --targets tmp/targets"

# compliant_updater.py supports the following keytypes.
keytype: ed25519, ecdsa

# compliant_updater.py expects the Root file to be signed by a max of 3 different keys.
number-of-root-keys: 3

# At a minimum, the Root file MUST be signed by at least 2 out of 3 Root keys.
root-threshold: 2
...
```
The updater is expected to exit with the following return codes in the
following situations:

[TODO: These return codes are not yet finalized]

```
return code      outcome
-----------      ------
0                success
1                unsigned metadata error
2                unknown target error
3                malicious target
4                rollback error
5                endless data error
...
```

## Example

Suppose a developer is interested in adopting the framework and wants to verify
that his Python implementation is compliant with the specification.  He can
begin by creating a script that accepts input metadata and, when certain
attacks are present, exits with the return codes defined in this TAP.  The
script can simply be an interface, or wrapper, to the developer's actual Python
implementation, which in production raises exceptions when an error occurs.
Furthermore, consider that the implementation might use a different
command-line interface from the one used by the script.  The developer's
script, which behaves according to this TAP, can be similar to
[this](https://github.com/theupdateframework/tuf/blob/tap7/tuf/scripts/conformance_tester/compliant_updater.py).
compliant updater written in Python.

A user can run the developer's script, `compliant_updater.py`, to initiate a
normal update (e.g., to download the `foo.tgz` package).  In this case, the
script refreshes top-level metadata to ensure that it has the latest repository
information, downloads the requested `foo.tgz` file, and exits with a return code
of `0`.  The output after running the script (and verifying the script's return
code with the `echo $?` command) would be as follows:

```Bash
$ python compliant_updater.py
  --file foo.tgz
  --remote-files tmp/romote-files
  --metadata tmp/metadata
  --targets tmp/targets

$ echo $?
0
```

Similarly, the conformance tool is able to execute the script with the same
command-line arguments and examine the outcome.  For instance, the conformance
tool can check the metadata that is saved to *tmp/metadata* and confirm that the
Snapshot, Targets, and Timestamp metadata were saved to the *tmp/metadata*
directory. (And according to the Root file that was loaded from *tmp/metadata*
prior to the start of the update call, and generated by the conformance tool).
Additionally, it can compare the `foo.tgz` saved to *tmp/targets* with the valid
one provided by the conformance tool via the --remote-files command-line
option.

`compliant_updater.py` can also be tested by the conformance tool against the
known updater attacks, including the rollback attack.  In the following
execution of the script, assume that metadata provided by the conformance tool
is correctly signed, but an older version of previously trusted metadata.


```Bash
$ python compliant_updater.py
  --file foo.tgz
  --remote-files tmp/remote-files
  --metadata tmp/metadata
  --targets tmp/targets

Error: Downloaded Timestamp metadata is older than the currently trusted version

$ echo $?
4
```

As before, the conformance tool is able to use this excution of the script to
verify the expected return code of `5`, and that certain top-level metadata and
the `foo.tgz` were unsuccessfully saved to the *tmp/metadata* and *tmp/targets*
directories, respectively.

Now, suppose that the Python implementation has the following restrictions:

```
(1) metadata is encoded in DER (rather than JSON)
(2) only Ed25519 keys are used and listed in metadata
(3) the Root file must be signed by 1 out of 2 keys (i.e., threshold of 1)
```

Items 2 & 3, of the list above, can be configured with the conformance tool via
its `.tuf-tester.yml` configuration file.  The configuration file can be edited
by the developer to list:

```
command: "python compliant_updater.py
  --file foo.tgz
  --remote-files tmp/remote-files
  --metadata tmp/metadata
  --targets tmp/targets"

keytype: ed25519
number-of-root-keys: 2
root-threshold: 1
```

Next, since the developer's implementation uses DER metadata (rather than
JSON), the conformance tool would have to incorporate metadata that the
developer's script and Python implementation can handle.  For this task, the
developer would need to provide the conformance tool with a path to a program
that converts JSON to DER metadata.  In this way, prior to calling the
developer's script and initiating an update, the conformance tool can call the
external program to convert JSON metadata into DER format.

The command, and its output, that a user can run to test the developer's Python
implementation for conformance would be similar the following:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
  --convert-metadata path/to/convert-json-to-der.py

normal update: check.
blocked slow retrieval attack: check.
blocked rollback attack: check.
key revocation: check.
blocked endless data attack: check.
...

Congratulations! The implementation under test appears to conform with the TUF
specification.  More detailed information on the test results was saved to
test-results.txt
```


A JSON-to-DER converter, `convert_signed_metadata_to_der()`, can be found
[here](https://github.com/awwad/tuf/blob/36dbb7b8a800dab407fe9ab961155ef0a6d9f7c9/tuf/asn1_codec.py#L156-L352).
Those curious as to how JSON metadata can be converted to another encoding can
reference the linked example to learn more.

It should be noted at this point that there might be implementations of the
framework where metadata or update files are not saved to a file system on the
device.  In this case, the developer or user running the conformance tests
would need to arrange for the files that are requested and stored by the device
to be saved to directories that *can* be accessed by the conformance tests.
These directories would be specified in the command-line options of the
compliant updater or the conformance tool's configuration file (i.e., the
--metadata and --targets command-line options used in the preceding examples).

What the conformance tool must ultimately verify are the metadata and update
file(s) that the updater eventually trusts, and not that these files are
"installed" in some particular manner. Additionally, the conformance tests must
confirm the updater's ability to detect the attacks covered in the
specification (with the exlusion of the slow retrieval attack).

Since testing of the slow retrieval attack depends on the transport mechanism
used by the implementation, it is up to the developer to test whether the
implementation is vulnerable to the slow retrieval attack.  This might entail
modifying an HTTP server to limit the rate at which requests are satisifed, or
inserting a MITM that intercepts XMLRPC traffic between the updater and server,
and then manipulating the rate of transfer.  Regardless of the transport
mechanism used, developers should take care to prevent their updaters from
being vulnerable to such attacks, which can happen before any data is
transferred, or after the it has begun.

Lastly, a summary of the steps followed to test an updater for conformance with
the specification is provided next.

```
(1) provide interface to updater that accepts metadata and exits with the
    TAP 7 return codes
(2) configure conformance tool to abide by the adopter's repository restrictions
(3) configure conformance tool to convert JSON metadata to the encoding used
    by the adopter, if necessary
(4) run conformance tool and confirm that all tests pass.
```

# Security Analysis

This TAP does not detract from existing security guarantees because it does not
propose architectual changes to the specification.

# Backwards Compatibility

This TAP does not introduce any backwards incompatibilities.

# Augmented Reference Implementation


A git branch containing the official tool for conformance testing and a client
set up for conformance testing:
https://github.com/theupdateframework/tuf/tree/tap7/tuf/scripts/conformance_tester

# Copyright

This document has been placed in the public domain.
