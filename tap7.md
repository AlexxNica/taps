* TAP: 7
* Title: Conformance testing
* Version: 1
* Last-Modified: 01-May-2017
* Author: Vladimir Diaz, Sebastien Awwad
* Status: Draft
* Content-Type: text/markdown
* Created: 20-Jan-2017

# Abstract

[Conformance testing](https://en.wikipedia.org/wiki/Conformance_testing) can
determine whether an implementation meets the requirements set by a
specification.  At this point, no tool exists to help developers and users test that an
implementation behaves according to the TUF specification. Although the reference implementation contains [unit
tests](https://github.com/theupdateframework/tuf/tree/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/tests)
that verify correct behavior, such as updating metadata in the expected order
and blocking known updater attacks, these unit tests only work only within the
parameters of the reference implementation.  It is important that conformance testing work across
different languages and platforms.  To achieve this aim, this
specification endorses a single official tool, compatible with any implementation,
and presents guidelines for using such a tool to establish a protocol for conformance testing.

# Motivation

Up to this point, adopters of TUF who had written an implementation could only test
for conformance by (1) verifying that metadata generated in some language X
matches that of the reference implementation, and/or (2) reproducing the unit
tests of the reference implementation in language X.  In the first case, only
the metadata generated by X can be said to conform to the specifications. The client
would still need to test for the expected behavior when the generated
metadata is updated.  In the second case, the implementation is said to
conform depending on how thoroughly the unit tests are reproduced in X.
There are bound to be inconsistencies between both sets of unit tests. Any
improvements in TUF testing or changes to the program would require
implementers to add test code in parallel.  A
single tool for conformance testing can avoid issues with interoperability and
duplicate work, can ensure update behavior as intended by the designers of the
framework, and, most importantly, ensure that an updater is secure against
the types of attacks and weaknesses listed in [Section
1.5.2](https://github.com/theupdateframework/tuf/blob/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/docs/tuf-spec.txt#L124-L181) of the TUF Specification. In addition, the official tool should be publicly 
available and useable by anyone who wishes to test an implementation.

Passing a conformance test with the official tool would be
an important step in checking if an implementation is TUF-compliant.

# Rationale

Developers need a convenient way of verifying whether an implementation
conforms to the TUF specification. Such a verification could be quite desirable,
as it would show the tested implementation meets a recognized standard of 
secure operation. One possible verification method could be to define, and ideally
automate, the expected outcome of an update request given different sets of
input metadata. If an implementation is given the Root file and instructed to
download a particular package, its ability to correctly download both the required
top-level metadata and the requested package could indicate conformance.  Moreover,
if does it do so while still preventing the attacks listed in the specification would make that
claim stronger.  Consequently, an
implementation of the framework would need some way of accepting given metadata
and indicating when it has detected a particular attack.

This TAP prescribes that an implementation, or a wrapper script for it, accept
a set of command-line arguments, which are defined here, and exit with return
codes under certain conditions (e.g., to signal that a Freeze attack was
detected).  A fixed set of arguments is needed so that conformance testing is
consistent across different languages.  In turn, the conformance tester will
execute the implementation with different sets of metadata and verify its exit
codes for numerous outcomes.  The conformance tester proposed here also requires a minimum
number of arguments so that it can thoroughly cover all potential outcomes that
it wishes to test.  It should be noted, however, that the implementation does
not necessarily have to be the updater used in production. It only needs to
function as defined in this TAP for conformance testing.

# Specification

An implementation under test will need to accept command-line arguments that indicate
(1) the target file to download when the program initiates an update,
(2) a directory containing the metadata and targets provided to the updater,
and (3) the location where requested metadata and target files are saved unmodified after a
request is made by the updater.  Specifically, the implementation needs to
accept the command-line arguments as follows:

```Bash
$ command foo.tgz tmp/repository-files tmp/client-metadata tmp/client-targets
```

A Python example:

```Bash
$ python compliant_updater.py
  --file foo.tgz
  --repository-files tmp/repository-files
  --client-metadata tmp/client-metadata
  --client-targets tmp/client-targets
```

In turn, the conformance tester tool executes this command when it runs its
suite of tests.  These tests will assess things such as validation of the metadata
downloaded by the updater, and verify that the following attacks and
weaknesses are protected against:

```
(1) arbitrary installation
(2) endless data
(3) extraneous dependencies
(4) fast-forward
(5) indefinite freeze
(6) malicious mirrors
(7) mix-and-match
(8) rollback
(9) vulnerability to key compromises.
```

During this process, the tester tool verifies that the expected metadata and
update files are downloaded, and examines the return codes of the program when
attacks on the updater are present, as defined later in this 
section.  Note that the conformance tester generates the metadata
and files that the implementation uses, and can test for various conditions
and metadata.  For instance, the tester tool can generate metadata 
signed by an invalid key, so it can test whether the implementation rejects
the untrusted signature.

### Configuration File
To launch the test, the conformance tester accepts a
command-line option (and others, which will be covered later) that point to
the location of a configuration file:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
```

The configuration file includes the update command that the tool will
execute to run the updater, along with restrictions, such as the
cryptographic key types supported by the updater, the number of root keys,
thresholds, etc.  The configuration file is needed because restrictions
are not shared equally across all implementations.
For example, the Go implementation might only support ECDSA keys, whereas
another might support Ed25519 and RSA keys.

### root.json
Before running the conformance tests, the tool generates a
`root.json` according to the restrictions set in `.tuf-tester.yml`, saves it to
*tmp/client-metadata* (or the path indicated by the `client-metadata`
command-line option), populates the directory containing the remote repository
files, and executes the update command.  At a minimum, TUF requires clients to
have the root.json locally, prior to initiating an update request.  The updater
should load *tmp/client-metadata/root.json* (or the appropriate path), refresh
metadata accordingly, and fetch the requested update file.

### Update Procedure
The update procedure of the program, which is to refresh metadadata and
download a single update file, is sufficient to cover all the requirements set
by the specification.  As brief examples: the conformance tool can start the
update program and feed it the correct metadata and update file when the
requests are made.  The tool will inspect the local metadata directory to
ensure that the correct metadata is downloaded, and that the update program
succeeds by returning a code of `0`.  The tool can test the program for
detection of a rollback attack by providing a previously trusted version of
metadata (and thus update files), and confirming that the program exits with a
return code of `4` (defined in this TAP to mean that a
rollback error has occurred).

### Executing Conformance Testing
The conformance tester stores `root.json` in the metadata directory indicated
on the command line (e.g., *tmp/client-metadata* above).  The root file is
generated according to the restrictions set in the configuration file.

The command to execute the conformance testing tool is:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
```

The conformance tester returns `0` if the implementation complies with the
specification.

conformance_tester.py returns a non-zero return code to signal a failure.
Optionally, a list of the conformance tests that the updater failed is printed
or logged.

An example of a `.tuf-tester.yml` configuration file for a Python updater:

```
# The command that the conformance tester executes to verify compliant_updater.py's
# conformity with the specification.
command: "python compliant_updater.py
  --file foo.tgz
  --repository-files tmp/repository-files
  --client-metadata tmp/client-metadata
  --client-targets tmp/client-targets"

# compliant_updater.py supports the following keytypes.
keytype: ed25519, ecdsa

# compliant_updater.py expects the Root file to be signed by a max of 3 different keys.
number-of-root-keys: 3

# At a minimum, the Root file MUST be signed by at least 2 out of 3 Root keys.
root-threshold: 2
...
```
The updater is expected to exit with the following return codes in the
following situations:

[TODO: These return codes are not yet finalized]

```
return code      outcome
-----------      ------
0                success
1                unsigned metadata error
2                unknown target error
3                malicious target
4                rollback error
5                endless data error
...
```

## Example

Suppose a developer is interested in adopting the framework and wants to verify
that his Python implementation is compliant with the specification.  He can
begin by creating a script that accepts input metadata and, when certain
attacks are present, exits with the return codes defined in this TAP.  The
script can simply be an interface, or wrapper, to the developer's actual Python
implementation, which in production raises exceptions when an error occurs.
Furthermore, consider that the implementation might use a different
command-line interface from the one used by the script.

In the example code below, the `metadata_directory` and `targets_directory`
arguments correspond to the --client-metadata and --client-targets command-line arguments,
respectively.  The 'target' argument is the --file update file that the
implementation is expected to securely update.

```Python
def update_client(target, metadata_directory, targets_directory):

  # The HTTP repository that serves metadata and update files to client.  Not
  # all implementations of the framework use this transport mechanism to serve
  # files.
  REPOSITORY_MIRROR = http://localhost:8001

  # Set the local repository directory containing all of the metadata files.
  tuf.settings.repositories_directory = metadata_directory

  # Set the repository mirrors.  This dictionary is needed by the Updater
  # client.
  repository_mirrors = {'mirror': {'url_prefix': REPOSITORY_MIRROR,
                                  'metadata_path': 'metadata',
                                  'targets_path': 'targets'}}

  # Create the repository object using the repository name 'repository'
  # and the repository mirrors defined above.
  updater = tuf.client.updater.Updater('repository', repository_mirrors)

  # The local destination directory to save the target files, which
  # we get from the command line argument supplied to this wrapper script.
  destination_directory = targets_directory

  # Refresh the repository's top-level roles, store the target information for
  # all the targets tracked, and determine which of these targets have been
  # updated.
  updater.refresh(unsafely_update_root_if_necessary=False)

  # Retrieve the target info of the 'target' argument, which contains its
  # length, hash, etc.
  file_targetinfo = updater.get_one_valid_targetinfo(target)
  updated_targets = updater.updated_targets([file_targetinfo], destination_directory)

  # Download each of these updated targets and save them to the local
  # 'targets_directory' supplied to the script.  The conformance tool
  # can verify the files saved unmodified to 'targets_directory'.
  updater.download_target(file_targetinfo, destination_directory)
```

As shown in the code snippet above, the script loads metadata from the
directory specified in the --client-metadata command-line option, and sets it
via the implementation's `tuf.settings.repositories_directory` configuration
setting.  The script also saves updated files to the directory indicated with
--client-targets, which the testing tool can use for verification.

The part of the developer's script, which captures the exceptions of the
original implementation and exits with the expected return codes, can resemble
the following snippet of code:


```Python
  # Parse the options.
  (target, metadata_directory, targets_directory) = parse_options()

  # Return codes for compliant_updater.py.  This list is not yet finalized.
  SUCCESS = 0
  UNSIGNED_METADATA_ERROR = 1
  UNKNOWN_TARGET_ERROR = 2
  MALICIOUS_TARGET_ERROR = 3
  ROLLBACK_ERROR = 4
  ENDLESS_DATA_ERROR = 5
  REPOSITORY_ERROR = 6
  UNKNOWN_ERROR = 7

  # Perform an update for 'target'.  The updated target is saved unmodified to
  # 'targets_directory', and refreshed metadata to 'metadata_directory'.  Any
  # exceptions raised are caught here, and the program ends with an appropriate
  # return code.
  try:
    update_client(target, metadata_directory, targets_directory)

  except (tuf.exceptions.NoWorkingMirrorError) as exception:

    # 'exception.mirror_errors' should only contain one (key, value) dict
    # entry, since only a single mirror is queried.
    for mirror_url, mirror_error in six.iteritems(exception.mirror_errors):
      sys.stderr.write('Error: ' + str(mirror_error) + '\n')

      if isinstance(mirror_error, tuf.exceptions.ReplayedMetadataError):
        sys.exit(ROLLBACK_ERROR)

      elif isinstance(mirror_error, tuf.exceptions.Error):
        sys.exit(ENDLESS_DATA_ERROR)

      elif isinstance(mirror_error, tuf.exceptions.RepositoryError):
        sys.exit(REPOSITORY_ERROR)

      # catch other known error conditions here...

      else:
        sys.exit(UNKNOWN_ERROR)

  # Successfully updated the target file.
  sys.exit(SUCCESS)
```

A user can run the developer's script, `compliant_updater.py`, to initiate a
normal update (e.g., to download the `foo.tgz` package).  In this case, the
script refreshes top-level metadata to ensure that it has the latest repository
information, downloads the requested `foo.tgz` file, and exits with a return code
of `0`.  The output after running the script (and verifying the script's return
code with the `echo $?` command) would be as follows:

```Bash
$ python compliant_updater.py
  --file foo.tgz
  --repository-files tmp/repository-files
  --client-metadata tmp/client-metadata
  --client-targets tmp/client-targets

$ echo $?
0
```

Similarly, the conformance tool is able to execute the script with the same
command-line arguments and examine the outcome.  For instance, the tool can
check the metadata saved unmodified to *tmp/client-metadata* and confirm that
the Snapshot, Targets, and Timestamp metadata were saved unmodifed to the
*tmp/client-metadata* directory, and according to the Root file loaded from
*tmp/client-metadata* prior to the start of the update call, and generated by
the conformance tool.  Additionally, it can compare the `foo.tgz` saved
unmodified to *tmp/client-targets* with the valid one provided by the
conformance tool via the --repository-files command-line option.

`compliant_updater.py` can also be tested by the conformance tool against the
known updater attacks, including the rollback attack.  In the following
execution of the script, assume that metadata provided by the conformance tool
is correctly signed, but an older version of previously trusted metadata.


```Bash
$ python compliant_updater.py
  --file foo.tgz
  --repository-files tmp/repository-files
  --client-metadata tmp/client-metadata
  --client-targets tmp/client-targets

Error: Downloaded Timestamp metadata is older than the currently trusted version

$ echo $?
4
```

As before, the conformance tool is able to use this execution of the script to
verify the expected return code of `5`, and that certain top-level metadata and
the `foo.tgz` were unsuccessfully saved unmodified to the *tmp/client-metadata*
and *tmp/client-targets* directories, respectively.

Now, suppose that the Python implementation has the following restrictions:

```
(1) metadata is encoded in DER (rather than JSON)
(2) only Ed25519 keys are used and listed in metadata
(3) the Root file must be signed by 1 out of 2 keys (i.e., threshold of 1)
```

Items 2 & 3, of the list above, can be configured with the conformance tool via
its `.tuf-tester.yml` configuration file.  The configuration file can be edited
by the developer to list:

```
command: "python compliant_updater.py
  --file foo.tgz
  --repository-files tmp/repository-files
  --client-metadata tmp/client-metadata
  --client-targets tmp/client-targets"

keytype: ed25519
number-of-root-keys: 2
root-threshold: 1
```

Next, since the developer's implementation uses DER metadata (rather than
JSON), the conformance tool would have to incorporate metadata that the
developer's script and Python implementation can handle.  For this task, the
developer would need to provide the conformance tool with a path to a program
that converts JSON to DER metadata.  In this way, prior to calling the
developer's script and initiating an update, the conformance tool can call the
external program to convert JSON metadata into DER format.

The command, and its output, that a user can run to test the developer's Python
implementation for conformance would be similar to the following:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
  --convert-metadata path/to/convert-json-to-der.py

normal update: check.
blocked freeze attack: check.
blocked rollback attack: check.
key revocation: check.
blocked endless data attack: check.
...

Congratulations! The implementation under test appears to conform with the TUF
specification.  More detailed information on the test results was saved to
test-results.txt
```

A JSON-to-DER converter, `convert_signed_metadata_to_der()`, can be found
[here](https://github.com/awwad/tuf/blob/36dbb7b8a800dab407fe9ab961155ef0a6d9f7c9/tuf/asn1_codec.py#L156-L352).
Those curious as to how JSON metadata can be converted to another encoding can
reference the linked example to learn more.

(NOTE: The code block in the link would be something we could prominently
mention in the re-organized example section.  I am not listing here the full
function (in the link) because it's too much and it wouldn't make much sense
on its own.)


It should be noted at this point that there might be implementations of the
framework where metadata or update files are not saved to a file system on the
device.  In this case, the developer or user running the conformance tests
would need to arrange for the files that are requested and stored by the device
to be saved unmodified to directories that *can* be accessed by the conformance
tests.  These directories would be specified in the command-line options of the
compliant updater or the conformance tool's configuration file (i.e., the
--client-metadata and --client-targets command-line options used in the
preceding examples).

What the conformance tool must ultimately verify are the metadata and update
file(s) that the updater eventually trusts, and not that these files are
"installed" in some particular manner. Additionally, the conformance tests must
confirm the updater's ability to detect the attacks covered in the
specification (with the exclusion of the slow retrieval attack).

Since testing of the slow retrieval attack depends on the transport mechanism
used by the implementation, it is up to the developer to test whether the
implementation is vulnerable to this attack.  This might entail
modifying an HTTP server to limit the rate at which requests are satisifed, or
inserting a MITM that intercepts XMLRPC traffic between the updater and server,
and then manipulating the rate of transfer.  Regardless of the transport
mechanism used, developers should take care to prevent their updaters from
being vulnerable to such attacks, which can happen before any data is
transferred, or after the transfer of data has begun.

Lastly, a summary of the steps followed to test an updater for conformance with
the specification is provided next.

```
(1) provide interface to updater that accepts metadata and exits with the
    TAP 7 return codes
(2) configure conformance tool to abide by the adopter's repository restrictions
(3) configure conformance tool to convert JSON metadata to the encoding used
    by the adopter, if necessary
(4) run conformance tool and confirm that all tests pass.
```

# Security Analysis

This TAP does not detract from existing security guarantees because it does not
propose architectual changes to the specification.

# Backwards Compatibility

This TAP does not introduce any backwards incompatibilities.

# Augmented Reference Implementation


A git branch containing the official tool for conformance testing and a client
set up for conformance testing can be found at:
https://github.com/theupdateframework/tuf/tree/tap7/tuf/scripts/conformance_tester

# Copyright

This document has been placed in the public domain.
