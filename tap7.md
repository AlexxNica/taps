* TAP: 7
* Title: Conformance testing
* Version: 2
* Last-Modified: 25-May-2017
* Author: Vladimir Diaz, Sebastien Awwad
* Status: Draft
* Content-Type: text/markdown
* Created: 20-Jan-2017

# Abstract

[Conformance testing](https://en.wikipedia.org/wiki/Conformance_testing) can
determine whether an implementation meets the requirements set by a given
specification.  At this point, no tool exists to help developers and users affirm
that an implementation behaves according to the TUF specification. Although
the reference implementation contains [unit
tests](https://github.com/theupdateframework/tuf/tree/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/tests)
that verify correct behavior, such as updating metadata in the expected order
and blocking known updater attacks, these unit tests only work within the
parameters of the reference implementation, which is problematic due to the diversity
of TUF implementations.

To achieve the goal of testing diverse TUF implementations, this specification describes the
design of a common testing tool for TUF conformance.  The goals are to interoperate with
implementations in diverse languages and environments, while having a low burden on
TUF implementers to the tool in their environment.

# Motivation

Up to this point, adopters of TUF who had written an implementation could only test
for conformance by (1) verifying that metadata generated in some language X
matches that of the reference implementation, and/or (2) reproducing the unit
tests of the reference implementation in language X.  In the first case, only
the metadata generated by X can be said to conform to the specifications. The client
would still need to test for the expected behavior when the generated
metadata is updated.  In the second case, the implementation is said to
conform depending on how thoroughly the unit tests are reproduced in X.
There are bound to be inconsistencies between the two sets of unit tests. Any
improvements in TUF testing or changes to the program would require
implementers to add test code in parallel.  A
single tool for conformance testing can avoid issues with interoperability and
duplicate work, can ensure update behavior as intended by the designers of TUF,
and, most importantly, ensure that an updater is secure against
the types of attacks and weaknesses listed in
[Section 1.5.2](https://github.com/theupdateframework/tuf/blob/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/docs/tuf-spec.txt#L124-L181)
of the TUF Specification. In addition, the official tool should be publicly
available and useable by anyone who wishes to test an implementation.

Passing a conformance test with the official tool would be
an important step in checking if an implementation is TUF-conformant.

# Rationale

Developers need a convenient way of verifying whether an implementation
conforms to the TUF specification. Such a verification could be quite desirable,
as it would affirm that the tested implementation meets a recognized standard of
secure operation. One possible verification method could be to define, and ideally
automate, the expected outcome of an update request when given different sets of
input metadata. If an implementation is given the Root file and instructed to
download a particular package, its ability to correctly download both the required
top-level metadata and the requested package could indicate conformance.  Moreover,
if it is able to do so while still preventing the attacks listed in the specification,
that claim becomes stronger.  Consequently, any
implementation of TUF would need some way of accepting given metadata
and indicating when it has detected a particular attack.

This TAP prescribes that an implementation of a client updater ("Updater")
employ a wrapper module ("Wrapper") that implements a common set of functions
defined in this document. These can be called by a general TUF Conformance
Tester ("Tester"), which will pass in sets of metadata and target files. The
Tester will determine based on output produced by the wrapped Updater --
including error codes that signal that particular attacks have been detected --
whether or not the Updater is conformant with the TUF specification. In
general, these constitute a battery of attacks against which the Updater should
be resilient.

It should be noted, however, that the implementation does not necessarily have
to be the updater used in production. It only needs to function as defined in
this TAP for conformance testing, though it is expected that the behavior be
the same at a high level -- for example, the validity of metadata should be
determined the same way. ((TODO: This paragraph still seems wordy. Unnecessary?))

# Specification

In order to help determine the TUF-conformance of a particular updater
implementation, the following components are required by this TAP:
- Updater
- Conformance Tester
- Wrapper

The **Updater** is the program to be tested, an implementation of a TUF-conformant
updater client, as described in
[the client section of the TUF specification](https://github.com/theupdateframework/tuf/blob/develop/docs/tuf-spec.txt#L931-L933).

The **Conformance Tester**, provided by TheUpdateFramework, will run a battery
of tests intended to determine the TUF-conformance of the Updater. The Tester
can be thought of as a source of metadata and targets that will ultimately be
received by the Updater, which must try to validate them correctly. The Updater
will be expected to reject untrustworthy metadata and targets and accept
trustworthy metadata and targets.

The **Wrapper** mediates communication between the Tester and Updater, adapting
metadata and communicating it in the way the Updater expects. An
individual Updater will need a custom Wrapper written for the Tester to use to
communicate with it. This will need to involve at least a few lines of Python.
In order for the Tester to interact with the Updater implementation, a Wrapper
around that implementation will need to support as an interface to the Tester
the 3-5 functions listed below.


## Wrapper Specification

The Wrapper must implement at least the first three functions specified
[below](#wrapper-functions).
Note also, however, that because implementations may vary substantially, the
Wrapper may need to perform things like:
 - Calling an external binary with, e.g., the subprocess module, in order to
 run an updater implementation that is not in Python.
 - Moving metadata or target files into the directory structure the updater
 implementation expects
 - If, e.g., the Updater doesn't have a notion of a filesystem, the wrapper may
 need to read the files the tester provides and distribute data to the Updater
 in the manner the Updater expects.
 - Translate metadata from the format the tester provides into the custom
 format the Updater expects (optional functions 4 and 5)
 - If the Updater's communication model involves different synchronization
 (e.g. server push vs client pull), the update_client() Wrapper function will
 need to bridge this; for example, it may need to wait and collect results from
 some separate process.



### Wrapper Functions
The following functions must be written for the Wrapper module, and will be
called by the Tester. The first three are required, and the last two are only
necessary if the format of metadata varies from that employed by the TUF
specification.

- 1: **`initialize_updater(metadata_directory)`**:
    - Purpose:
        Sets the client's initial state up for a future test, providing it with
        metadata to be treated as already-validated. A client updater delivered
        to end users will always need some kind of root of trust (in the TUF
        spec, an initial Root role metadata file, e.g. root.json) to use when
        validating future metadata.

    - Arguments:
        - `metadata_directory`:
          Metadata in the TUF specification's metadata format will be provided in
          the directory at path `metadata_directory`. This should be provided to
          the Updater in whatever form it requires. The common case here will be
          the path of a directory containing a trustworthy root.json file.

    - Returns: None

- 2: **`update_repo(metadata_directory, targets_directory)`**:
    - Purpose:
        Updates the repository files, metadata and targets. This will be the
        data that should be made available to the Updater when the Updater
        tries to update.

    - Arguments:
        - `metadata_directory`:
          As above, `metadata_directory` will be the path of a directory
          containing metadata files in the format specified in the TUF
          specification.
        - `targets_directory`:
          the path of a directory containing target files that should be made
          available to the Updater.

    - Returns: None


- 3: **`update_client(target_filepath)`**:
    - Purpose:
        Refreshes metadata and causes the client to attempt to (obtain and)
        validate a particular target,
        along with all metadata required to do so in a secure manner conforming to
        the TUF specification.

        This function will have to translate Updater behavior/output into the
        return values (below) that the Tester expects, based on
        whether or not the Updater detects a particular attack. `update_client`
        must return the appropriate code to the Tester, which will evaluate them
        against what it expects.

    - Arguments:
        - `target_filepath`:
          The path of a target file that the Updater should try to update.
          This must be inside the `targets_directory` directory provided to
          `update_repo`, and it should be written relative to
          `targets_directory`. As noted previously, it is not necessary for the
          Updater to have a notion of files; `update_client` may abstract this
          away.

    - Returns:
        An integer describing the result of the attempted update. This value is
        what the Tester is ultimately testing.

        ```
        return value     outcome
        -----------      ------
        0                SUCCESS: target identified by target_filepath has been
                         obtained from one of the mirrors and validated per
                         trustworthy metadata
        1                FAILURE/rejection: unable to obtain a target identified
                         by target_filepath from any of the known mirrors that
                         is valid according to trustworthy metadata
        2                an unknown error has occurred (never expected, but
                         helpful to provide for test output)

        # TODO: Consider additional return fields:
          hash: (Verdict: No, for now)
            the hash of the target file installed if there was a target file
            validated and "installed" (to be tested against the expected
            fileinfo). This may allow us to make sure that the success was real
            / the right target was actually chosen.
            This is probably not necessary, but it's food for thought as we
            write tests.

          metadata versions: (Verdict: No)
            a dictionary mapping metadata filename to the version validated in
            this update. The purpose of this is to allow for an easier time
            writing the Tester, since it spares us the complication of making
            the test go so far as to validate a particular target in a large
            number of sub-tests when all we want to do is determine that e.g.
            replayed metadata is rejected. Tests are just more complicated to
            construct sometimes otherwise. Not a good enough reason, IMO;
            simplicity for the external implementer is paramount.

        ```

- 4: **`transform_metadata_for_signing(metadata_dict)`** (optional):
    NOTE THAT THIS IS OPTIONAL, only necessary if the format of metadata
    must vary from the JSON described in the TUF specification.

    - Purpose:
        Converts raw role metadata in a JSON-compatible format described in the
        TUF specification (in 'signed' fields in signed metadata) into metadata
        of the format that the Updater expects to check signatures over.
        This will be what the Tester signs (instead of the JSON-compatible
        'signed' element) when it signs metadata.
        (((TODO: Elaborate with example.)))

    - Arguments:
        - `metadata_dict`:
          Metadata for one role.
          A dictionary conforming to
          [tuf.formats.ANYROLE_SCHEMA](https://github.com/theupdateframework/tuf/blob/develop/tuf/formats.py#L388-L390)
          that contains role metadata as specified by the TUF specification.
          This will be the metadata in the 'signed' element in familiar .json
          metadata files.

    - Returns:
        A bytes() object over which the Tester can sign, which will be what the
        Updater/Wrapper checks when it tests the validity of the metadata against
        a signature.

- 5: **`transform_finished_metadata(metadata_w_signatures_dict)`** (optional):
    NOTE THAT THIS IS OPTIONAL, only necessary if the format of metadata
    must vary from the JSON described in the TUF specification.

    - Purpose:
        Converts raw role metadata in a JSON-compatible format described in the
        TUF specification (in 'signed' fields in signed metadata) into metadata
        of the format that the Updater expects to see and check signatures over.
        (((TODO: Elaborate with example.)))

    - Arguments:
        - `metadata_w_signatures_dict`:
          Metadata for one role plus signature(s) over it.
          A dictionary conforming to
          [tuf.formats.SIGNABLE_SCHEMA](https://github.com/theupdateframework/tuf/blob/develop/tuf/formats.py#L305-L309)
          that contains role metadata and a signature/signatures over (a
          transformed version of) it.

    - Returns:
        A bytes() object which can be written to a file in binary mode, resulting
        in a metadata file that the Wrapper can (modify if necessary and) provide
        to the Updater.



<!---
(((DEBUG: Here, for reference, are the scraps of an old error list I started to
rewrite, which I now think is an unnecessary complication for implementers.)))
value  meaning
-----  ------------------------------------------------
0.     Success
        (successful update of indicated target file (target_filepath)

1.     Target not validated by signed hash
         (bad target / bad signature; signed hash in validated metadata does
          not match the Target provided)
2.     Metadata not validated by signature
         (bad metadata / bad signature; signature on a role does not match the
          metadata in that role)
3.     Replayed metadata
         (version of a role provided for validation is less than the previous
          version already validated by the Updater)
4.     Expired metadata
         (current date/time is later than the expiration date in the metadata
          provided for validation)
5.     Endless data / expected size exceeded
         (a target file is being provided that has exceeded the size listed
          for the target in validated metadata)
6. ...

```
-->



See [Example Wrapper](#example-wrapper) below for an example of the Wrapper
module - in this case, a wrapper enabling the Conformance Tester to test the
TUF Reference Implementation.


## Test Specification

The Tester will verify that the Updater can
defend against the attacks and weaknesses discussed in the TUF specification.
Broadly, these include:

```
(1) arbitrary installation
(2) endless data
(3) extraneous dependencies
(4) fast-forward
(5) indefinite freeze
(6) malicious mirrors
(7) mix-and-match
(8) rollback
(9) vulnerability to key compromises
```

Note that the Conformance Tester generates the metadata
and files that the implementation uses, and can test for various conditions.
For instance, the Tester can generate metadata signed by an invalid key,
so it can test whether the implementation will reject
an untrusted signature.


### Test Battery

(((Note: we should decide whether or not to include the full listing of
conformance tests here. Since expected Updater behavior is part of the
specification, I think this test battery should be maintained as a sort of part
of the spec, whether here or in a linked document. I suppose it depends on how
long that is.)))

A set of static metadata may also be provided, but the best results will come
from metadata and targets dynamically generated by the Tester.

In each of the tests below, the new metadata to be validated, provided in the
`update_repo` call, will describe a new target. This new target will not have
been described by the initial metadata that the client is treating as already-
validated (provided in `initialize_updater` call). When the `update_client`
call specifies this new target, that target will only validate if the new
metadata has been validated and the target obtained matches that now-validated
metadata.


#### Case Multipliers
When a Case Set below lists one of these multipliers, the number of tests of
that case set will need to be multiplied in the listed way.
- **Per Role**
    - Run the case at least four different ways, where the offending metadata
      is a different role: Timestamp, Snapshot, Target, and Root.
      If delegated target roles are supported (See
      [Configuration File](#configuration-file)), then a delegated target role
      file should also be tested.
- **Mirrors**
    - Run the case in two scenarios:
        - 2 attack mirrors
          - Setup is as listed
          - Return value expected is as listed
        - 1 attack mirror, 1 good mirror
          - The attack mirror is as described, and the good mirror lacks the
            malicious modification described.
          - The return value expected is always Success (0)
            (A bad mirror should not be able to prevent update from a
             good mirror; that would be an easy denial of service attack.)
    - Note that if the particular Updater doesn't support multiple mirrors,
      (see [Configuration File](#configuration-file)), then the two cases above
      should be:
        - 1 attack mirror instead of 2 attack mirrors
        - 1 good mirror instead of 1 good mirror and 1 bad mirror

#### Case Sets

These can be expanded to indicate more about the definitions of the test cases,
e.g. what calls are made to the Wrapper and a description of the arguments
provided (e.g. the files in the directories indicated by the arguments)

##### Normal case
  - Description: A normal update with all-valid metadata.
  - Return: 0: success
  - Multipliers: none

##### Target tampering w/ no compromised keys
  - Return Value Expected: Failure (1)
  - Description: Metadata is unaltered, but the target file is altered and does
    not match signed hash in metadata.
  - Multipliers: Per Role x Mirrors

##### Metadata tampering w/ no compromised keys
  - Return Value Expected: Failure (1)
  - Description: Signed metadata is altered and the signature
    on that signed metadata is unaltered and no longer valid.
  - Multipliers: Per Role x Mirrors

##### Freezes / Expired metadata provided for validation
  - Return Value Expected: Failure (1)
  - Description: The metadata role in question is altered to make its
    expiration earlier than the current date/time (to test expiry)
  - Multipliers: Per Role x Mirrors

##### Replays
  - Return Value Expected: Failure (1)
  - Description: A metadata role provided for validation by the mirror has a
    lower version number than that of the corresponding role that has already
    been validated.
  - Multipliers: Per Role x Mirrors

...
ETC
...




## Example Wrapper

Here's a sample Wrapper module that allows the Conformance Tester to test the
TUF Reference Implementation.

(((TODO: NOTE that I need to continue to go through the below. It's
not finished. I also have to indent the below properly. (Avoiding now to avoid
misleading commit diffs))))

```Python

def initialize_updater(metadata_directory):
# TODO: Copy the contents of the given directory to a temp directory and host
# that via http simpleserver on port 8001 on localhost.
# TODO: Initialize a tuf.client.updater.Updater object and stick the given
# metadata files into its current metadata directory. (Such code exists in the
# Uptane demo already. Grab from there.)

# The HTTP repository that serves metadata and update files to client.  Not
# all implementations of the framework use this transport mechanism to serve
# files.
REPOSITORY_MIRROR = http://localhost:8001

# Set the local repository directory containing all of the metadata files.
tuf.settings.repositories_directory = metadata_directory

# Set the repository mirrors.  This dictionary is needed by the Updater
# client.
repository_mirrors = {'mirror': {'url_prefix': REPOSITORY_MIRROR,
                                'metadata_path': 'metadata',
                                'targets_path': 'targets'}}

# Create the repository object using the repository name 'repository'
# and the repository mirrors defined above.
updater = tuf.client.updater.Updater('repository', repository_mirrors)

# The local destination directory to save the target files, which
# we get from the command line argument supplied to this wrapper script.
destination_directory = targets_directory

# ...


def update_repo(metadata_directory, targets_directory):
# TODO: Copy the given files into place in the hosted repository directory.


def update_client(target_filepath):

# Refresh the repository's top-level roles, store the target information for
# all the targets tracked, and determine which of these targets have been
# updated.
updater.refresh(unsafely_update_root_if_necessary=False)

# Retrieve the target info of the 'target_filepath' argument, which contains
# its length, hash, etc.
file_targetinfo = updater.get_one_valid_targetinfo(target_filepath)
updated_targets = updater.updated_targets([file_targetinfo], destination_directory)

# Download each of these updated targets and save them to the local
# 'targets_directory' supplied to the script.  The conformance tool
# can verify the files saved unmodified to 'targets_directory'.
try:
  updater.download_target(file_targetinfo, destination_directory)

except tuf.NoWorkingMirrorError:
  return FAILURE

# TODO: Check if the target file has been obtained and retained post-validation
if #obtained and retained#:
  return SUCCESS
else:
  return FAILURE
```

As shown in the code snippet above, the Wrapper functions loads metadata from
the directories specified. The Updater.download_target() call in the TUF
reference implementation employs the suite of TUF verifications to obtain the
target file indicated and retain it only if it validates, updating metadata as
necessary.


### Configuration File
To launch the test, the conformance tester accepts a
command-line option that points to
the location of a configuration file.

The configuration file includes the name of the module that provides the
Wrapper functions specified above, along with any necessary restrictions on
TUF functionality, such as the list of
cryptographic key types supported by the updater, the number of root keys,
thresholds, etc.  The configuration file is needed because restrictions
are not shared equally across all implementations.
For example, the Go implementation might only support ECDSA keys, whereas
another might support Ed25519 and RSA keys.

An example of a `.tuf-tester.yml` configuration file for a Python updater:

```
# The name of the Wrapper module, which will be imported and used by the
# Tester.
module: ref_impl_wrapper

# conformant_updater.py supports the following keytypes.
keytype: ed25519, ecdsa

# conformant_updater.py expects the Root file to be signed by a max of 3 different keys.
number-of-root-keys: 3

# For this Updater implementation, at a minimum, the Root file MUST be signed
# by at least 2 out of 3 Root keys.
root-threshold: 2

# Let's say that this Updater implementation doesn't support delegated Targets
# roles. (Default is true.)
delegated-roles-support: false

# Let's say that this Updater implementation doesn't support mirrors - it just
# uses one location for the repository. (Default is true.)
mirror-support: false
...
```

### Executing Conformance Testing
The command to execute the conformance testing tool is:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
```

In response, you'll likely see something along these lines:
```
normal update: check.
blocked freeze attack: check.
blocked rollback attack: check.
key revocation: check.
blocked endless data attack: check.
...

Congratulations! The implementation under test appears to conform with the TUF
specification.  More detailed information on the test results was saved to
test-results.txt
```

The conformance tester returns `0` if all tests return results as expected,
indicating that the implementation conforms to the specification.

If `conformance_tester.py` returns a non-zero return code,
it signals a failure. Optionally, a list of the conformance tests that the
updater failed is printed or logged.


### Dealing with Implementation Restrictions

#### Key Restrictions

Suppose, for example, that the Updater implementation has the following restrictions:
```
- only Ed25519 keys are used and listed in metadata
- only exactly 2 keys are supported for Root metadata, and only a threshold
    of 1  (((Is this necessary?)))
```
These restrictions can be handled by configuring the conformance tool via
its `.tuf-tester.yml` configuration file.  The configuration file can be edited
by the developer to list:

```
keytype: ed25519
number-of-root-keys: 2
root-threshold: 1
```

#### Metadata Conversion

Suppose that metadata that the Updater reads must be encoded in DER (rather
than JSON).

In this case, the Conformance Tester has to incorporate metadata that the
developer's script and implementation can handle.  For this task, the two
optional Wrapper functions `transform_metadata_for_signing` and
`transform_finished_metadata`, specified in
[Wrapper Functions](#wrapper-functions) above, should be implemented to
perform these conversions. The Tester will call these as appropriate.

For an example of how these might look, consider the JSON-to_DER converter
`convert_signed_metadata_to_der` employed by Uptane's TUF fork
[here](https://github.com/awwad/tuf/blob/36dbb7b8a800dab407fe9ab961155ef0a6d9f7c9/tuf/asn1_codec.py#L156-L352).
Those curious as to how JSON metadata can be converted to another encoding can
reference the linked example to learn more.

(((TODO: I should probably add the *high-level* code here to do the ASN.1/DER
conversion, which is pretty short (asn1_coder.convert*(), inside function
definition blocks for the optional functions, to make this clearer to the
reader.))))


#### No File System
There might be TUF implementations
where metadata or update files are not saved to a file system on the
device.  In this case, the developer or user running the conformance tests
would need to arrange that the files which are requested and stored by the device
be saved unmodified to directories that *can* be accessed by the conformance
tests.  These directories would be specified in the command-line options of the
conformant updater or the conformance tool's configuration file (i.e., the
--client-metadata and --client-targets command-line options used in the
preceding examples).

What the conformance tool must ultimately verify are the metadata and update
file(s) that the updater eventually trusts, and not that these files are
"installed" in some particular manner. Additionally, the conformance tests must
confirm the updater's ability to detect the attacks covered in the
specification (with the exclusion of the slow retrieval attack).

Since testing of the slow retrieval attack depends on the transport mechanism
used by the implementation, it is up to the developer to test whether the
implementation is vulnerable to this attack.  This might entail
modifying an HTTP server to limit the rate at which requests are satisifed, or
inserting a MITM that intercepts XMLRPC traffic between the updater and server,
and then manipulating the rate of transfer.  Regardless of the transport
mechanism used, developers should take care to prevent their updaters from
being vulnerable to such attacks, which can happen before any data is
transferred, or after the transfer of data has begun.


## Summary of Steps for Conformance Testing
In summary, the steps that should be followed to test an Updater for
conformance to the TUF Specification are as follows:

```
(1) Write Wrapper module per specifications above.
(2) Configure conformance tool to abide by the adopter's repository restrictions.
(3) Run conformance tool and confirm that all tests are passed.
```

# Security Analysis

This TAP does not detract from existing security guarantees because it does not
propose architectual changes to the specification.

# Backwards Compatibility

This TAP does not introduce any backwards incompatibilities.

# Augmented Reference Implementation


A git branch containing the official tool for conformance testing, and a client
set up for conformance testing can be found at:
https://github.com/theupdateframework/tuf/tree/tap7/tuf/scripts/conformance_tester

**Note that the preceding must be updated to match recent modifications to
TAP 7.**


# Copyright

This document has been placed in the public domain.
