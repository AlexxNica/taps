* TAP: 7
* Title: Conformance testing
* Version: 1
* Last-Modified: 25-Jan-2017
* Author: Vladimir Diaz, Sebastien Awwad, Justin Cappos
* Status: Draft
* Content-Type: text/markdown
* Created: 20-Jan-2017

# Abstract

[Conformance testing](https://en.wikipedia.org/wiki/Conformance_testing) can
determine whether an implementation meets the requirements set by a
specification.  A tool that helps developers and users test that an
implementation bahaves according to the TUF specification does not presently
exist.  Although the reference implementation contains [unit
tests](https://github.com/theupdateframework/tuf/tree/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/tests)
that verify correct behavior, such as updating metadata in the expected order
and blocking known updater attacks, these unit tests only work with the
reference implementation.  Conformance testing should instead work across
different languages and platforms.  In other words, the specification should
endorse an official tool, compatible with any implementation, and cover how an
implementation can be set up for conformance testing.

# Motivation

An adopter of the framework, say a developer that has written an implementation
in language X, can currently test for conformance by (1) verifying that
metadata generated in X matches that of the reference implementation, and/or
(2) reproducing the unit tests of the reference implementation in language X.
In the first case, only the metadata generated by X can be said to be
conformant.  However, the client would still need to be tested for the expected
behavior when the generated metadata is updated.  In the second case, the
implementation is said to be conformant depending on how thoroughly the unit
tests are reproduced in X.  There are bound to be inconsistencies between both
sets of unit tests, so a single tool is preferable.  A single tool for
conformance testing can avoid issues with interoperability, duplicate work,
ensuring update behavior as intended by the designers of the framework, and
most importantly it can certify that an updater is secure against the attacks
and weaknesses listed in [section
1.5.2](https://github.com/theupdateframework/tuf/blob/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/docs/tuf-spec.txt#L124-L181)
(Goals for specific attacks to protect against) of the specification.

An implementatation can be said to be TUF-compliant if it passes conformance
testing with the official tool.

# Rationale

Developers of an implementation who wish to undergo conformance testing are
required to provide a program, or script, that accepts a specific set of
command-line arguments.  The program should be able perform a secure update.  A
fixed set of arguments are needed so that compliance testing is consistent
across different programs.  The compliance tester also requires a minimum
number of arguments so that it can thoroughly cover all potential outcomes that
it wishes to test.  It should be noted, however, that this program does not
necessarily have to be the updater used in production, only that it should
function as defined in this TAP for compliance testing only.

The program itself accepts a command-line argument that indicates the target
file to download when the program initiates an update, the location of a TUF
repository that satisfies requests for metadata and targets, and where
downloaded metadata files and the target file are saved when the program
initiates an update.  Specifically, the program can be called as follows:

```Bash
$ command foo.tgz http://localhost:8001 tmp/metadata tmp/targets
```

A Python example:

```Bash
$ python test-updater.py foo.tgz --repo http://localhost:8001 --metadata tmp/metadata --targets tmp/targets
```

In turn, the conformance tester executes this command when it runs its suite of
compliance tests, which will consist of testing for things like validating the
metadata downloaded by the updater and verifying that the following attacks are
blocked:

```
(1) Arbitrary installation (2) endless data (3) extraneous dependencies (4)
fast-forward (5) indefinite freeze (6) malicious mirrors (7) mix-and-match (8)
rollback (9) slow retrieval, (10) key compromise.
```

While testing, the compliance tester will inspect the state of the downloaded
metadata and examine the return codes of the program when attacks on the
updater are present, which are defined later in the `Specification` section of
this TAP.  The compliance tester is in control of the repository specified on
the command-line.

As for running the compliance-tester, the compliance-tester tool accepts a
single command-line option that points to the location of a configuration file:

```Bash
$ python compliance-tester.py --config tmp/.tuf-tester.yml
```

The configuration file includes the command that it should execute to run the
updater, and other restrictions such as the cryptography key types supported by
the updater, the number of root keys, thresholds, etc.  Why is a configuration
file needed?  There are restrictions set by different implementation that,
although they abide by the specification, are not shared across all
implementations of the specification.  For example, the Go implementation might
only support ECDSA keys, whereas another might support Ed25519 and RSA keys.

Before beginning compliance testing, the compliance testing tool will generate
a `root.json` according to the restrictions set in `.tuf-tester.yml`, save it
to --metadata tmp/metadata, populate and start a TUF repository, and execute
the update command.  The updater should load tmp/metadata/root.json, refresh
metadata accordingly, and fetch the target file.

The update procedure of the program, which is to refresh metadadata and
download a single target file, is sufficient to cover all the requirements set
by the specification [TODO: at least this is my conclusion, but I am open to
feedback].  As brief examples: the tool can start the update program and feed
it the correct metadata and target file when the requests are made.  It will
inspect the local metadata directory to ensure that the correct metadata was
downloaded, that they are signed properly, and that the update program succeeds
with a return code of `0`.  The tool can test the program for detection of a
slow retrieval attack by starting a server that provides data at a slow rate,
and confirming that the program returns a code of `5` (a return code of `5` is
defined in this TAP to mean that a slow retrieval error has occurred).

# Specification

`root.json` exists in `tmp/metadata`, which is stored there by the
compliance tester.  The root file is generated according to the restrictions
set in the configuration file.

The command to execute the compliance testing tool is:

```Bash
$ python updater.py --config tmp/tuf_compliance_tester.yml
```

Here is an example command for the Python updater:

```Bash
$ python compliance_tester.py --updater "python updater.py --repo
http://localhost:8001 --metadata tmp/metadata --targets tmp/targets foo.tgz"
```

The compliance tester returns `0` if the implementation complies with the
specification.

compliance_tester.py returns a non-zero return code to signal a failure.
Optionally, a list of the compliance tests that the updater failed is printed
or logged.

An example of a `.tuf-tester.yml` configuration file:

```
command: "python test-updater.py foo.tgz --repo http://localhost:8001 --metadata tmp/metadata --targets tmp/targets"
keytype: ed25519, ecdsa
number-of-root-keys: 3
root-threshold: 2
...
```

And return codes are defined for different outcomes:
[TODO: These return codes are not yet finalized]

```
return code      result
-----------      ------
0                success
1                unsigned metadata error
2                unknown target error
3                malicious target
4                rollback error
5                slow retrieval error
6                endless data error
...
```

# Security Analysis

This TAP does not detract from existing security guarantees because it does
not propose architectual changes to the specification.

# Backwards Compatibility

This TAP does not introduce any backwards incompatibilities.

# Augmented Reference Implementation

[TODO: Point to a branch containing the official tool for conformance testing,
and a client set up for conformance testing.]

# Copyright

This document has been placed in the public domain.
