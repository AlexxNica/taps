* TAP: 7
* Title: Conformance testing
* Version: 2
* Last-Modified: 24-May-2017
* Author: Vladimir Diaz, Sebastien Awwad
* Status: Draft
* Content-Type: text/markdown
* Created: 20-Jan-2017

# Abstract

[Conformance testing](https://en.wikipedia.org/wiki/Conformance_testing) can
determine whether an implementation meets the requirements set by a given
specification.  At this point, no tool exists to help developers and users affirm
that an implementation behaves according to the TUF specification. Although
the reference implementation contains [unit
tests](https://github.com/theupdateframework/tuf/tree/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/tests)
that verify correct behavior, such as updating metadata in the expected order
and blocking known updater attacks, these unit tests only work within the
parameters of the reference implementation, which is problematic due to the diversity
of TUF implementations.

To achieve the goal of testing diverse TUF implementations, this specification describes the
design of a common testing tool for TUF conformance.  The goals are to interoperate with
implementations in diverse languages and environments, while having a low burden on
TUF implementers to the tool in their environment.

# Motivation

Up to this point, adopters of TUF who had written an implementation could only test
for conformance by (1) verifying that metadata generated in some language X
matches that of the reference implementation, and/or (2) reproducing the unit
tests of the reference implementation in language X.  In the first case, only
the metadata generated by X can be said to conform to the specifications. The client
would still need to test for the expected behavior when the generated
metadata is updated.  In the second case, the implementation is said to
conform depending on how thoroughly the unit tests are reproduced in X.
There are bound to be inconsistencies between the two sets of unit tests. Any
improvements in TUF testing or changes to the program would require
implementers to add test code in parallel.  A
single tool for conformance testing can avoid issues with interoperability and
duplicate work, can ensure update behavior as intended by the designers of TUF,
and, most importantly, ensure that an updater is secure against
the types of attacks and weaknesses listed in [Section
1.5.2](https://github.com/theupdateframework/tuf/blob/6fde6222c9c6abf905ef4a56cf56fe35c4a85e14/docs/tuf-spec.txt#L124-L181) of the TUF Specification. In addition, the official tool should be publicly
available and useable by anyone who wishes to test an implementation.

Passing a conformance test with the official tool would be
an important step in checking if an implementation is TUF-conformant.

# Rationale

Developers need a convenient way of verifying whether an implementation
conforms to the TUF specification. Such a verification could be quite desirable,
as it would affirm that the tested implementation meets a recognized standard of
secure operation. One possible verification method could be to define, and ideally
automate, the expected outcome of an update request when given different sets of
input metadata. If an implementation is given the Root file and instructed to
download a particular package, its ability to correctly download both the required
top-level metadata and the requested package could indicate conformance.  Moreover,
if it is able to do so while still preventing the attacks listed in the specification,
that claim becomes stronger.  Consequently, any
implementation of TUF would need some way of accepting given metadata
and indicating when it has detected a particular attack.

This TAP prescribes that an implementation, or a wrapper script for it, accept
a set of command-line arguments as defined in this document, and exit with return
codes under certain conditions (e.g., to signal that a Freeze attack was
detected).  A fixed set of arguments is needed so that conformance testing is
consistent across different languages.  In turn, the conformance tester will
execute the implementation with different sets of metadata and verify its exit
codes for numerous outcomes.  The conformance tester proposed here also requires
a minimum number of arguments so that it can thoroughly cover all potential
outcomes for which it wishes to test.  It should be noted, however, that the
implementation does not necessarily have to be the updater used in production.
It only needs to function as defined in this TAP for conformance testing.

# Specification

In order to help determine the TUF-conformance of a particular updater
implementation, the following components are required by this TAP:
- Updater
- Conformance Tester
- Wrapper

The **Updater** is the program to be tested, an implementation of a TUF-conformant
updater client, as described in
[the client section of the TUF specification](https://github.com/theupdateframework/tuf/blob/develop/docs/tuf-spec.txt#L931-L933)
.

The **Conformance Tester**, provided by TheUpdateFramework, will run a battery
of tests intended to determine the TUF-conformance of the Updater. The Tester
can be thought of as a source of metadata and targets that will ultimately be
received by the Updater, which must try to validate them correctly. The Updater
will be expected to reject untrustworthy metadata and targets and accept
trustworthy metadata and targets.

The **Wrapper** mediates communication between the Tester and Updater, adapting
metadata and communicating it in the way the Updater expects. An
individual Updater will need a custom Wrapper written for the Tester to use to
communicate with it. This will need to involve at least a few lines of Python.
In order for the Tester to interact with the Updater implementation, a Wrapper
around that implementation will need to support the following few functions as
an interface to the tester. The tester will interact with the implementation by
calling these functions, providing as arguments metadata and/or target/image
files. These functions are `initialize_client`, `update_repo`, and
`update_client`. They and other Wrapper functionality are specified in
[the Wrapper Specification section below](#wrapper_specification).


## Wrapper Specification

The Wrapper must implement three functions specified [below](#wrapper_functions).
Note also, however, that because implementations may vary substantially, the
Wrapper may need to perform things like:
 - Calling an external binary with, e.g., the subprocess module, in order to
 run an updater implementation.
 - Moving metadata or target files into the directory structure the updater
 implementation expects
 - If, e.g., the Updater doesn't have a notion of a filesystem, the wrapper may
 need to read the files the tester provides and distribute data to the Updater
 in the manner the Updater expects.
 - Translate metadata from the format the tester provides into the custom
 format the Updater expects
 - If the Updater's communication model involves different synchronization
 (e.g. server push vs client pull), the update_client() Wrapper function will
 need to bridge this; for example, it may need to wait and collect results from
 some separate process.



### Wrapper Functions
The following functions must be written for the Wrapper module, and will be
called by the Tester.

- **`initialize_client(metadata_directory)`**:
    Purpose:
      Sets the client's initial state up for a future test, providing it with
      metadata to be treated as already-validated. A client updater delivered
      to end users will always need some kind of root of trust (in the TUF
      spec, an initial Root role metadata file, e.g. root.json) to use when
      validating future metadata.

    Arguments:
      `metadata_directory`:
        Metadata in the TUF specification's metadata format will be provided in
        the directory at path `metadata_directory`. This should be provided to
        the Updater in whatever form it requires. The common case here will be
        the path of a directory containing a trustworthy root.json file.

    Returns: None

- **`update_repo(metadata_directory, targets_directory)`**:
    Purpose:
      Updates the repository files, metadata and targets. This will be the data
      that should be made available to the Updater when the Updater tries to
      update.

    Arguments:
      `metadata_directory`:
        As above, `metadata_directory` will be the path of a directory
        containing metadata files in the format specified in the TUF
        specification.
      `targets_directory`:
        the path of a directory containing target files that should be made
        available to the Updater.

    Returns: None


- **`update_client(target_filepath)`**:
    Purpose:
      Causes the client to attempt to (obtain and) validate a particular target,
      along with all metadata required to do so in a secure manner conforming to
      the TUF specification.

      This function will have to translate Updater behavior/output into the
      return values (below) that the Tester expects, based on
      whether or not the Updater detects a particular attack. `update_client`
      must return the appropriate code to the Tester, which will evaluate them
      against what it expects.

    Arguments:
      `target_filepath`:
        The path of a target file that the Updater should try to update.
        This must be inside the `targets_directory` directory provided to
        `update_repo`, and it should be written relative to
        `targets_directory`. As noted previously, it is not necessary for the
        Updater to have a notion of files; `update_client` may abstract this
        away.

    Returns:
      An integer describing the result of the attempted update, matching the
      set listed in [Expected Output](#expected_output). This value is what
      the Tester is ultimately testing.

      Note that this list is not yet finalized.
      # TODO: Add blurb briefly describing each status below.
      # TODO: Connect each status to the TUF Specification.
      # TODO: Complete list by walking through what is expected for each
      #       test scenario.

      return value     outcome
      -----------      ------
      0                success: target at target_filepath is trustworthy
      1                unsigned metadata / invalid signature on metadata
      2                unknown target (necessary?)
      3                malicious target (?)
      4                rollback attack detected, update rejected (replay?)
      5                endless data attack detected, update rejected
      7                an unknown error has occurred

      # TODO: Consider additional return values:
        hash: (Verdict: unsure. "No" for now.)
          the hash of the target file installed if there was a target file
          validated and "installed" (to be tested against the expected
          fileinfo). This may allow us to make sure that the success was real /
          the right target was actually chosen.
        metadata versions: (Verdict: No: not necessary, I think)
          a dictionary mapping metadata filename to the version validated in
          this update. The purpose of this is to allow for an easier time
          writing the Tester, since it spares us the complication of making the
          test go so far as to validate a particular target when all we want
          to do is determine that e.g. replayed metadata is rejected. Tests are
          just more complicated to construct sometimes otherwise. Not a good
          enough reason, IMO.

See [Example Wrapper](#example_wrapper) below for an example of the Wrapper
module - in this case, a wrapper enabling the Conformance Tester to test the
TUF Reference Implementation.


## Test Specification

The Tester will verify that the Updater can
defend against the following attacks and weaknesses:

```
(1) arbitrary installation
(2) endless data
(3) extraneous dependencies
(4) fast-forward
(5) indefinite freeze
(6) malicious mirrors
(7) mix-and-match
(8) rollback
(9) vulnerability to key compromises.
```

Note that the Conformance Tester generates the metadata
and files that the implementation uses, and can test for various conditions.
For instance, the tester tool can generate metadata signed by an invalid key,
so it can test whether the implementation will reject
an untrusted signature.

### Setting Up a TUF Implementation to Work with the Tool
Suppose a developer is interested in adopting TUF and wants to verify
that his Python implementation is conformant with the specification.  He can
begin by creating a script that accepts input metadata and, when certain
attacks are present, exits with the return codes defined in this TAP.  The
script can simply be an interface, or wrapper, to the developer's actual Python
implementation, which in production raises exceptions when an error occurs.
Furthermore, consider that the implementation might use a different
command-line interface from the one used by the script.

In the example code below, the `metadata_directory` and `targets_directory`
arguments correspond to the --client-metadata and --client-targets command-line
arguments, respectively.  The 'target' argument is the --file update file that the
implementation is expected to securely update.

```Python
def update_client(target, metadata_directory, targets_directory):

# The HTTP repository that serves metadata and update files to client.  Not
# all implementations of the framework use this transport mechanism to serve
# files.
REPOSITORY_MIRROR = http://localhost:8001

# Set the local repository directory containing all of the metadata files.
tuf.settings.repositories_directory = metadata_directory

# Set the repository mirrors.  This dictionary is needed by the Updater
# client.
repository_mirrors = {'mirror': {'url_prefix': REPOSITORY_MIRROR,
                                'metadata_path': 'metadata',
                                'targets_path': 'targets'}}

# Create the repository object using the repository name 'repository'
# and the repository mirrors defined above.
updater = tuf.client.updater.Updater('repository', repository_mirrors)

# The local destination directory to save the target files, which
# we get from the command line argument supplied to this wrapper script.
destination_directory = targets_directory

# Refresh the repository's top-level roles, store the target information for
# all the targets tracked, and determine which of these targets have been
# updated.
updater.refresh(unsafely_update_root_if_necessary=False)

# Retrieve the target info of the 'target' argument, which contains its
# length, hash, etc.
file_targetinfo = updater.get_one_valid_targetinfo(target)
updated_targets = updater.updated_targets([file_targetinfo], destination_directory)

# Download each of these updated targets and save them to the local
# 'targets_directory' supplied to the script.  The conformance tool
# can verify the files saved unmodified to 'targets_directory'.
updater.download_target(file_targetinfo, destination_directory)
```

As shown in the code snippet above, the script loads metadata from the
directory specified in the --client-metadata command-line option, and sets it
via the implementation's `tuf.settings.repositories_directory` configuration
setting.  The script also saves updated files to the directory indicated with
--client-targets, which the testing tool can use for verification.

#### Exceptions
The part of the developer's script that captures the exceptions of the
original implementation and exits with the expected return codes can resemble
the following snippet of code:


```Python
  # Parse the options.
  (target, metadata_directory, targets_directory) = parse_options()

  # Return codes for conformant_updater.py.  This list is not yet finalized.
  SUCCESS = 0
  UNSIGNED_METADATA_ERROR = 1
  UNKNOWN_TARGET_ERROR = 2
  MALICIOUS_TARGET_ERROR = 3
  ROLLBACK_ERROR = 4
  ENDLESS_DATA_ERROR = 5
  REPOSITORY_ERROR = 6
  UNKNOWN_ERROR = 7

  # Perform an update for 'target'.  The updated target is saved unmodified to
  # 'targets_directory', and refreshed metadata to 'metadata_directory'.  Any
  # exceptions raised are caught here, and the program ends with an appropriate
  # return code.
  try:
    update_client(target, metadata_directory, targets_directory)

  except (tuf.exceptions.NoWorkingMirrorError) as exception:

    # 'exception.mirror_errors' should only contain one (key, value) dict
    # entry, since only a single mirror is queried.
    for mirror_url, mirror_error in six.iteritems(exception.mirror_errors):
      sys.stderr.write('Error: ' + str(mirror_error) + '\n')

      if isinstance(mirror_error, tuf.exceptions.ReplayedMetadataError):
        sys.exit(ROLLBACK_ERROR)

      elif isinstance(mirror_error, tuf.exceptions.Error):
        sys.exit(ENDLESS_DATA_ERROR)

      elif isinstance(mirror_error, tuf.exceptions.RepositoryError):
        sys.exit(REPOSITORY_ERROR)

      # catch other known error conditions here...

      else:
        sys.exit(UNKNOWN_ERROR)

  # Successfully updated the target file.
  sys.exit(SUCCESS)
```

### Configuration File
To launch the test, the conformance tester accepts a
command-line option (and others, which will be covered later) that point to
the location of a configuration file:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
```

The configuration file includes the update command that the tool will
execute to run the updater, along with restrictions, such as the
cryptographic key types supported by the updater, the number of root keys,
thresholds, etc.  The configuration file is needed because restrictions
are not shared equally across all implementations.
For example, the Go implementation might only support ECDSA keys, whereas
another might support Ed25519 and RSA keys.

### root.json
Before running the conformance tests, the tool generates a
`root.json` according to the restrictions set in `.tuf-tester.yml`, saves it to
*tmp/client-metadata* (or the path indicated by the `client-metadata`
command-line option), populates the directory containing the remote repository
files, and executes the update command.  At a minimum, TUF requires clients to
have the root.json locally, prior to initiating an update request.  The updater
should load *tmp/client-metadata/root.json* (or the appropriate path), refresh
metadata accordingly, and fetch the requested update file.

### Update Procedure
The update procedure of the program refreshes metadadata and
downloads the requested file.  As brief examples: the conformance tool can start the
update program and feed it the correct metadata and update file when the
requests are made.  The tool will inspect the local metadata directory to
ensure that the correct metadata is downloaded. If the update program
succeeds, it returns a code of `0`.

The tool can then check the program for
rollback attacks by providing a previously trusted version of
metadata (and thus update files), and confirming that the program exits with a
return code of `4`. As defined in this TAP, this number indicates that a
rollback error has occurred.

A user can run the developer's script, `conformant_updater.py`, to initiate a
normal update (e.g., to download the `foo.tgz` package).  In this case, the
script refreshes top-level metadata to ensure that it has the latest repository
information, downloads the requested `foo.tgz` file, and exits with a return code
of `0`.  The output after running the script (and verifying the script's return
code with the `echo $?` command) would be as follows:

```Bash
$ python conformant_updater.py
 --file foo.tgz
 --repository-files tmp/repository-files
 --client-metadata tmp/client-metadata
 --client-targets tmp/client-targets

$ echo $?
0
```

Similarly, the conformance tool is able to execute the script with the same
command-line arguments and examine the outcome.  For instance, the tool can
check the metadata saved unmodified to *tmp/client-metadata* and confirm that
the Snapshot, Targets, and Timestamp metadata were saved unmodified to the
*tmp/client-metadata* directory, according to the Root file loaded from
*tmp/client-metadata* prior to the start of the update call, and generated by
the conformance tool.  Additionally, it can compare the `foo.tgz` saved
unmodified to *tmp/client-targets* with the valid one provided by the
conformance tool via the --repository-files command-line option.

### Executing Conformance Testing
The conformance tester stores `root.json` in the metadata directory indicated
on the command line (e.g., *tmp/client-metadata* above).  The root file is
generated according to the restrictions set in the configuration file.

The command to execute the conformance testing tool is:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
```

The conformance tester returns `0` if the implementation conforms with the
specification. If conformance_tester.py returns a non-zero return code,
it signals a failure. Optionally, a list of the conformance tests that the
updater failed is printed or logged.

An example of a `.tuf-tester.yml` configuration file for a Python updater:

```
# The command that the conformance tester executes to verify conformant_updater.py's
# conformity with the specification.
command: "python conformant_updater.py
  --file foo.tgz
  --repository-files tmp/repository-files
  --client-metadata tmp/client-metadata
  --client-targets tmp/client-targets"

# conformant_updater.py supports the following keytypes.
keytype: ed25519, ecdsa

# conformant_updater.py expects the Root file to be signed by a max of 3 different keys.
number-of-root-keys: 3

# At a minimum, the Root file MUST be signed by at least 2 out of 3 Root keys.
root-threshold: 2
...
```
The updater is expected to exit with the following return codes in the
following situations:

[TODO: These return codes are not yet finalized]

```
return code      outcome
-----------      ------
0                success
1                unsigned metadata error
2                unknown target error
3                malicious target
4                rollback error
5                endless data error
...
```

### Dealing with Implementation Restrictions
Suppose, for example, that the Python implementation has the following restrictions:

```
(1) metadata is encoded in DER (rather than JSON)
(2) only Ed25519 keys are used and listed in metadata
(3) the Root file must be signed by 1 out of 2 keys (i.e., threshold of 1)
```

Items 2 & 3, of the list above, can be configured with the conformance tool via
its `.tuf-tester.yml` configuration file.  The configuration file can be edited
by the developer to list:

```
keytype: ed25519
number-of-root-keys: 2
root-threshold: 1
```

Next, since the developer's implementation uses DER metadata (rather than
JSON), the conformance tool would have to incorporate metadata that the
developer's script and Python implementation can handle.  For this task, the
developer would need to provide the conformance tool with a path to a program
that converts JSON to DER metadata.  In this way, prior to calling the
developer's script and initiating an update, the conformance tool can call the
external program to convert JSON metadata into DER format.

The command, and its output, that a user can run to test the developer's Python
implementation for conformance would be similar to the following:

```Bash
$ python conformance_tester.py
  --config tmp/.tuf-tester.yml
  --convert-metadata path/to/convert-json-to-der.py

normal update: check.
blocked freeze attack: check.
blocked rollback attack: check.
key revocation: check.
blocked endless data attack: check.
...

Congratulations! The implementation under test appears to conform with the TUF
specification.  More detailed information on the test results was saved to
test-results.txt
```

A JSON-to-DER converter, `convert_signed_metadata_to_der()`, can be found
[here](https://github.com/awwad/tuf/blob/36dbb7b8a800dab407fe9ab961155ef0a6d9f7c9/tuf/asn1_codec.py#L156-L352).
Those curious as to how JSON metadata can be converted to another encoding can
reference the linked example to learn more.

(NOTE: The code block in the link would be something we could prominently
mention in the re-organized example section.  I am not listing here the full
function (in the link) because it's too much and it wouldn't make much sense
on its own.)


It should be noted at this point that there might be TUF implementations
where metadata or update files are not saved to a file system on the
device.  In this case, the developer or user running the conformance tests
would need to arrange that the files which are requested and stored by the device
be saved unmodified to directories that *can* be accessed by the conformance
tests.  These directories would be specified in the command-line options of the
conformant updater or the conformance tool's configuration file (i.e., the
--client-metadata and --client-targets command-line options used in the
preceding examples).

What the conformance tool must ultimately verify are the metadata and update
file(s) that the updater eventually trusts, and not that these files are
"installed" in some particular manner. Additionally, the conformance tests must
confirm the updater's ability to detect the attacks covered in the
specification (with the exclusion of the slow retrieval attack).

Since testing of the slow retrieval attack depends on the transport mechanism
used by the implementation, it is up to the developer to test whether the
implementation is vulnerable to this attack.  This might entail
modifying an HTTP server to limit the rate at which requests are satisifed, or
inserting a MITM that intercepts XMLRPC traffic between the updater and server,
and then manipulating the rate of transfer.  Regardless of the transport
mechanism used, developers should take care to prevent their updaters from
being vulnerable to such attacks, which can happen before any data is
transferred, or after the transfer of data has begun.

Lastly, a summary of the steps that should be followed to test an
updater for conformance to TUF are as follows:

```
(1) provide interface to updater that accepts metadata and exits with the
    TAP 7 return codes.
(2) configure conformance tool to abide by the adopter's repository restrictions.
(3) configure conformance tool to convert JSON metadata to the encoding used
    by the adopter, if necessary.
(4) run conformance tool and confirm that all tests are passed.
```

# Security Analysis

This TAP does not detract from existing security guarantees because it does not
propose architectual changes to the specification.

# Backwards Compatibility

This TAP does not introduce any backwards incompatibilities.

# Augmented Reference Implementation


A git branch containing the official tool for conformance testing, and a client
set up for conformance testing can be found at:
https://github.com/theupdateframework/tuf/tree/tap7/tuf/scripts/conformance_tester

**Note that the preceding must be updated to match the modified spec.**


# Copyright

This document has been placed in the public domain.
